<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8"/>
<title>C++ jegyzet</title>
<link rel="stylesheet" href="css/sh_style.css"/>
<link rel="stylesheet" href="css/notes.css"/>
<meta name="viewport" content="width=device-width, user-scalable=no"/>
</head>
<body>
<ol>
<li><a href="#compiling">Fordítás</a></li>
</ol>
<article>
<section id="compiling">
<h1>Fordítás</h1>
<p>A futtatható állomány előállítása három lépésből áll: preprocesszálás
&rarr; fordítás &rarr; összeállítás (preprocessor &rarr; compiler &rarr;
linker).</p>
<h2>Preprocesszálás</h2>
<p>A preprocesszálás végeredménye ritkán jelenik meg külön állományként, a
fordítás részeként fut le.</p>
<pre class="sh_cpp" data-source="preproctest/preproctest.cc"></pre>
<pre class="sh_cpp" data-source="preproctest/some_header.h"></pre>
<p>Ha azt akarjuk, hogy a fordító csak preprocesszáljon, akkor a
<code>-E</code>
kapcsolót kell használnunk gcc vagy clang esetén. Ekkor a stdoutra kiírja
azt, ami egyébként a fordítónak ment volna. Ha a kimenetet megnézzük, az
include egyszerűen csak beilleszti a megadott állományt a forrásba, ezen
kívül belekerül pár különös jel, ezekkel tud a fordító a hibakijelzésnél
az eredeti források soraira hivatkozni.</p>
<pre class="console" data-source="preproctest/output.txt"></pre>
<h2>Fordítás</h2>
<p>A fordítás során minden egyes <code>.cc</code>/<code>.cpp</code>
forrásból objektum állomány (<code>.o</code>/<code>.obj</code>) készül.
Az objektum állomány tartalmazza, a változók neveit, a függvények neveit
és gépi kódú forrását, valamint hogy ezek a függvények hol hivatkoznak meg
változókat és más függvényeket. Itt még nincs eldöntve, hogy a memóriában
hol fognak az egyes függvény kódok és globális változók elhelyezkedni.</p>
<p>A külső nevek típusának az ellenőrzése a fordító feladata, de ahhoz, hogy
ezt megtehesse, tudnia kell róla.</p>
<pre class="sh_cpp" data-source="refer1/refer1.cc"></pre>
<pre class="sh_cpp" data-source="refer1/util.cc"></pre>
<p>Ha azt akarjuk, hogy csak a preprocesszáló és a fordító fusson le,
használjuk a <code>-c</code> kapcsolót.</p>
<pre class="console" data-source="refer1/output.txt"></pre>
<p>A máshol definiált függvényeket és globális változókat deklarálni minden
egyes forrásban, ahol használni akarjuk komoly hibaforrás és rengeteg
pluszmunka, ezért szokás egy <code>.h</code> forrásba beletenni mindazon
változókat és függvényeket, amit egy másik modul számára elérhetővé akarunk
tenni. Ezt teszi minden egyes rendszerkönyvtár.</p>
<pre class="sh_cpp" data-source="refer2/refer2.cc"></pre>
<pre class="sh_cpp" data-source="refer2/util.h"></pre>
<pre class="sh_cpp" data-source="refer2/util.cc"></pre>
<pre class="console" data-source="refer2/output.txt"></pre>
<p>Előfordulhat, hogy a <code>util.h</code>-ban definiált
<code>Record</code> típust használja több modul is, pl. a függvények
paraméterlistájában. Elkerülhetetlen, hogy emiatt közvetve többször is
befűződjön a <code>util.h</code>. A típust újradeklarálni viszont nem
lehet.</p>
<pre class="sh_cpp" data-source="refer2/include.cc"></pre>
<pre class="console" data-source="refer2/include.txt"></pre>
<p>Ezért szokás a fejléceket makrókkal körülbástyázni, hogy ha újra
megjelennének egy fordítási egységben, akkor lényegében nem tartalmaznak
semmit.</p>
<pre class="sh_cpp" data-source="refer2/util_safe.h"></pre>
<p>A gyakorlatban minden népszerű fordító támogatja a nem szabványos
<code class="inline sh_cpp">#pragma once</code> direktívát, amivel ugyanezt
lehet <a href="http://en.wikipedia.org/wiki/Pragma_once">egyetlen plusz sorral
megvalósítani</a>. A vizsgán ne használd.</p>
<p>Minden olyan függvényt, amit nem használunk modulon kívüli használatra
érdemes úgy deklarálnunk, hogy azt más modulok még véletlenül se érhessék
el, hogy egy nagyobb program esetén ne érjenek kellemetlen meglepetések.
C-ben ezt a static kulcsszó használatával lehet elérni, C++-ban lehetőség
van static kulcsszót használni vagy névtelen névteret létrehozni (a
névterekről később).</p>
<pre class="sh_cpp" data-source="refer3/util.cc"></pre>
<pre class="sh_cpp" data-source="refer3/refer3.cc"></pre>
<pre class="console" data-source="refer3/output.txt"></pre>
<p>A példában a <code>foo</code> változót megtalálta, de a <code>bar</code>t
nem.</p>
<h2>Összeállítás</h2>
<p>A linker feladata, hogy eldöntse, hogy futás során hol fognak
elhelyezkedni a memóriában a globális változók és a függvények gépi kódja,
és hogy ez utóbbiak a már megállapított címen keressék őket.</p>
<p>Nagyon fontos tudni, hogy a linkerben a C++ már díszített (decorated)
neveket használ, ellentétben a C-vel, mert C++-ban már nem elég pusztán a
függvény nevét tudni a beazonosításhoz.</p>
<pre class="sh_cpp" data-source="link1/util.c"></pre>
<pre class="sh_cpp" data-source="link1/link1.cc"></pre>
<pre class="console" data-source="link1/output.txt"></pre>
<p>A C++ kód nem látta azt a C függvényt, amelyiket nem <code
class="sh_cpp">extern "C"</code> kulcsszóval deklaráltunk, illetve a C kód
nem látta azt a C++ függvényt, amit nem ezzel a kulcsszóval definiáltunk.</p>
<p>Az <code class="sh_cpp">extern "C"</code> lényegében azt mondja: &bdquo;erre a
deklarációra vagy definícióra ne használj díszített neveket!&rdquo; Van
<code class="sh_cpp">extern "C" { /* ... */ }</code> formája is, amivel
egyszerre több deklarációra vagy definícióra lehet ezt a módot beállítani.
Elsősorban C rutinkönyvtárak fejléceiben találkozni vele:</p>
<pre class="sh_cpp">#ifdef __cplusplus
extern "C" {
#endif

/* ... */

#ifdef __cplusplus
}
#endif</pre>
</section>
</article>
<script type="application/javascript" src="js/sh_cpp.js"></script>
<script type="application/javascript" src="js/sh_main.js"></script>
<script type="application/javascript" src="http://ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
<script type="application/javascript" src="js/highlightDocument.js"></script>
</body>
</html>
