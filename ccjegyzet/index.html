<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8"/>
<title>C++ jegyzet</title>
<link rel="stylesheet" href="css/sh_style.css"/>
<link rel="stylesheet" href="css/notes.css"/>
<meta name="viewport" content="width=device-width, user-scalable=no"/>
</head>
<body>
<ol>
<li><a href="#compiling">Fordítás</a></li>
<li><a href="#newLanguageElements">Új nyelvi elemek</a></li>
<li><a href="#oo">Objektum-orientált fejlesztés</a></li>
</ol>
<article>
<section id="compiling">
<h1>Fordítás</h1>
<p>A futtatható állomány előállítása három lépésből áll: preprocesszálás
&rarr; fordítás &rarr; összeállítás (preprocessor &rarr; compiler &rarr;
linker).</p>
<h2>Preprocesszálás</h2>
<p>A preprocesszálás végeredménye ritkán jelenik meg külön állományként, a
fordítás részeként fut le.</p>
<pre class="sh_cpp" data-source="preproctest/preproctest.cc"></pre>
<pre class="sh_cpp" data-source="preproctest/some_header.h"></pre>
<p>Ha azt akarjuk, hogy a fordító csak preprocesszáljon, akkor a
<code>-E</code>
kapcsolót kell használnunk gcc vagy clang esetén. Ekkor a stdoutra kiírja
azt, ami egyébként a fordítónak ment volna. Ha a kimenetet megnézzük, az
include egyszerűen csak beilleszti a megadott állományt a forrásba, ezen
kívül belekerül pár különös jel, ezekkel tud a fordító a hibakijelzésnél
az eredeti források soraira hivatkozni.</p>
<pre class="console" data-source="preproctest/output.txt"></pre>
<h2>Fordítás</h2>
<p>A fordítás során minden egyes <code>.cc</code>/<code>.cpp</code>
forrásból objektum állomány (<code>.o</code>/<code>.obj</code>) készül.
Az objektum állomány tartalmazza, a változók neveit, a függvények neveit
és gépi kódú forrását, valamint hogy ezek a függvények hol hivatkoznak meg
változókat és más függvényeket. Itt még nincs eldöntve, hogy a memóriában
hol fognak az egyes függvény kódok és globális változók elhelyezkedni.</p>
<p>A külső nevek típusának az ellenőrzése a fordító feladata, de ahhoz, hogy
ezt megtehesse, tudnia kell róla.</p>
<pre class="sh_cpp" data-source="refer1/refer1.cc"></pre>
<pre class="sh_cpp" data-source="refer1/util.cc"></pre>
<p>Ha azt akarjuk, hogy csak a preprocesszáló és a fordító fusson le,
használjuk a <code>-c</code> kapcsolót.</p>
<pre class="console" data-source="refer1/output.txt"></pre>
<p>A máshol definiált függvényeket és globális változókat deklarálni minden
egyes forrásban, ahol használni akarjuk komoly hibaforrás és rengeteg
pluszmunka, ezért szokás egy <code>.h</code> forrásba beletenni mindazon
változókat és függvényeket, amit egy másik modul számára elérhetővé akarunk
tenni. Ezt teszi minden egyes rendszerkönyvtár.</p>
<pre class="sh_cpp" data-source="refer2/refer2.cc"></pre>
<pre class="sh_cpp" data-source="refer2/util.h"></pre>
<pre class="sh_cpp" data-source="refer2/util.cc"></pre>
<pre class="console" data-source="refer2/output.txt"></pre>
<p>Előfordulhat, hogy a <code>util.h</code>-ban definiált
<code>Record</code> típust használja több modul is, pl. a függvények
paraméterlistájában. Elkerülhetetlen, hogy emiatt közvetve többször is
befűződjön a <code>util.h</code>. A típust újradeklarálni viszont nem
lehet.</p>
<pre class="sh_cpp" data-source="refer2/include.cc"></pre>
<pre class="console" data-source="refer2/include.txt"></pre>
<p>Ezért szokás a fejléceket makrókkal körülbástyázni, hogy ha újra
megjelennének egy fordítási egységben, akkor lényegében nem tartalmaznak
semmit.</p>
<pre class="sh_cpp" data-source="refer2/util_safe.h"></pre>
<p>A gyakorlatban minden népszerű fordító támogatja a nem szabványos
<code class="inline sh_cpp">#pragma once</code> direktívát, amivel ugyanezt
lehet <a href="http://en.wikipedia.org/wiki/Pragma_once">egyetlen plusz sorral
megvalósítani</a>. A vizsgán ne használd.</p>
<p>Minden olyan függvényt, amit nem használunk modulon kívüli használatra
érdemes úgy deklarálnunk, hogy azt más modulok még véletlenül se érhessék
el, hogy egy nagyobb program esetén ne érjenek kellemetlen meglepetések.
C-ben ezt a static kulcsszó használatával lehet elérni, C++-ban lehetőség
van static kulcsszót használni vagy névtelen névteret létrehozni (a
névterekről később).</p>
<pre class="sh_cpp" data-source="refer3/util.cc"></pre>
<pre class="sh_cpp" data-source="refer3/refer3.cc"></pre>
<pre class="console" data-source="refer3/output.txt"></pre>
<p>A példában a <code>foo</code> változót megtalálta, de a <code>bar</code>t
nem.</p>
<h2>Összeállítás</h2>
<p>A linker feladata, hogy eldöntse, hogy futás során hol fognak
elhelyezkedni a memóriában a globális változók és a függvények gépi kódja,
és hogy ez utóbbiak a már megállapított címen keressék őket.</p>
<p>Nagyon fontos tudni, hogy a linkerben a C++ már díszített (decorated)
neveket használ, ellentétben a C-vel, mert C++-ban már nem elég pusztán a
függvény nevét tudni a beazonosításhoz.</p>
<pre class="sh_cpp" data-source="link1/util.c"></pre>
<pre class="sh_cpp" data-source="link1/link1.cc"></pre>
<pre class="console" data-source="link1/output.txt"></pre>
<p>A C++ kód nem látta azt a C függvényt, amelyiket nem <code
class="sh_cpp">extern "C"</code> kulcsszóval deklaráltunk, illetve a C kód
nem látta azt a C++ függvényt, amit nem ezzel a kulcsszóval definiáltunk.</p>
<p>Az <code class="sh_cpp">extern "C"</code> lényegében azt mondja: &bdquo;erre a
deklarációra vagy definícióra ne használj díszített neveket!&rdquo; Van
<code class="sh_cpp">extern "C" { /* ... */ }</code> formája is, amivel
egyszerre több deklarációra vagy definícióra lehet ezt a módot beállítani.
Elsősorban C rutinkönyvtárak fejléceiben találkozni vele:</p>
<pre class="sh_cpp">#ifdef __cplusplus
extern "C" {
#endif

/* ... */

#ifdef __cplusplus
}
#endif</pre>
</section>
<section id="newLanguageElements">
<h1>Új nyelvi elemek</h1>
<h2>A <code class="sh_cpp">const</code> kulcsszó</h2>
<p>Előnyei:</p>
<ul>
<li>Ha átadok egy mutatót egy függvénynek, biztos lehetek, hogy nem fog a
tartalma változni, és a fordítót is biztosítom erről: ennek megfelelően
optimizálhatja a kódot</li>
<li>Elegánsabban lehet vele konstanst definiálni, mint a <code
class="sh_cpp">#define</code> direktívával: a konstansnak lesz típusa, és
lehet címe (a prefix &amp; operátorral)</li>
</ul>
<pre class="sh_cpp" data-source="new/const.cc"></pre>
<pre class="console" data-source="new/const.txt"></pre>
<h2>Egyszerűbb függvény deklaráció</h2>
<p>C-ben a <code class="sh_cpp">int main()</code> <code class="sh_cpp">int
main(...)</code>-nak felelt meg, a paraméter nélküli függvényeket <code
class="sh_cpp">int main(void)</code>-ként kellett deklarálni. C++-ban ez már
nem érvényes, a <code class="sh_cpp">int main()</code> ekvivalens a <code
class="sh_cpp">int main(void)</code> deklarációval.</p>
<h2>Változó deklaráció bárhol</h2>
<p>Bárhol lehet változót deklarálni, nem csak a blokkok elején és a
for ciklusokban.</p>
<pre class="sh_cpp" data-source="new/decl.cc"></pre>
<h2>Függvények túlterhelése</h2>
<p>A függvényeket már nem csak a nevük, hanem a paraméterlistájuk is
azonosítja, amíg egyértelmű.</p>
<pre class="sh_cpp" data-source="new/overload.cc"></pre>
<pre class="console" data-source="new/overload.txt"></pre>
<p>Többek között emiatt van szükség az <code class="sh_cpp">extern "C"</code>
módosítóra.</p>
<h2>Függvény paraméter alapértelmezett értékek</h2>
<p>A függvény utolsó paramétereinek adhatunk alapértelmezett értéket, ezzel
azok a paraméterek elhagyhatóvá válnak. Paramétereket elhagyni csak a
függvény végéről lehet, nem lehet pl. a harmadikat elhagyni, a negyediket
viszont megadni.</p>
<pre class="sh_cpp" data-source="new/default.cc"></pre>
<pre class="console" data-source="new/default.txt"></pre>
<h2>Referenciák</h2>
<p>Mutatók mellett referenciákat is használhatunk. A háttérben ezek is
mutatók, de nem tudjuk a mutató értékét megváltoztatni, csak azt az értéket,
amire mutat.</p><p>Ha a referenciát const kulcsszóval deklaráljuk, a fordító
képes automatikusan ideiglenes változót létrehozni, ha kell (lásd a példát).
Ha azonban a visszatérési érték referencia, akkor a biztonságos működéshez
csak olyan referenciát adhatunk vissza, ami nincs a függvény élettartamához
kötve. Ha mégis megtesszük, a program még le is fordulhat, de nem várt
eredményeket produkálhat.</p>
<pre class="sh_cpp" data-source="new/ref.cc"></pre>
<pre class="console" data-source="new/ref.txt"></pre>
<h2><code class="sh_cpp">inline</code> függvények</h2>
<p>A <code class="sh_cpp">#define</code> direktívával létrehozott
makró-függvényeknek kellemetlen mellékhatásai lehetnek:</p>
<pre class="sh_cpp">#define MUL(a, b) a*b
// ...
#define SIX 1+5
#define NINE 8+1
int val = MUL(SIX, NINE);
// val erteke 42 (nem 54)</pre>
<p>Zárójelezéssel javíthatunk rajta, a deklaráció nem lett szebb, és még így
is problémáink akadhatnak:</p>
<pre class="sh_cpp">#define MAX(a, b) ((a)>(b)?(a):(b))
// ...
int a = 6;
int b = 5;
int val = MAX(++a, b);
// a es val erteke mar 8</pre>
<p>Ezen kívül ha makrókat használunk, nincsenek típusdeklarációk,
nem lehet használni a túlterhelést, az alapértelmezett értékeket,
és egyebeket, amikről eddig nem volt szó. De szeretnénk, ha nem
hajtana végre külön függvényhívást, ha a fordító is úgy gondolja,
hogy ez kézenfekvő.</p>
<pre class="sh_cpp">inline int max(int a, int b)
{
    return a > b ? a : b;
}
// ...
int a = 6;
int b = 5;
int val = max(++a, b);
// a es val erteke 7</pre>
<p>A fordító nem veszi figyelembe az <code class="sh_cpp">inline</code>
kulcsszót, ha</p>
<ul>
<li>a függvénynek címét vesszük, és azzal hívjuk meg (elvileg közvetlen
meghívásnál még mindig befűzheti a hívás helyett)</li>
<li>a függvény rekurzív</li>
<li>a függvény túl bonyolult vagy nagy</li>
<li>fordító hóbortból</li>
</ul>
<h2>Implicit <code class="sh_cpp">typedef</code> struktúrákra</h2>
<p>A struktúrákra nem kell ezentúl <code class="sh_cpp">struct
StrukturaNev</code> formában hivatkozni, simán <code
class="sh_cpp">StrukturaNev</code> is megteszi.</p>
<pre class="sh_cpp">struct Rect {
    int x, y;
    int width, height;
};

// OK
struct Rect rect1;

// C++-ban mar ez is OK
Rect rect2;</pre>
</section>
<section id="oo">
<h1>Objektum-orientált fejlesztés</h1>
<p>Az OOP lényege, hogy objektumokkal dolgozunk. Objektum lehet pl. egy
komplex szám, egy dinamikus tömb vagy egy gomb a képernyőn. Az objektumokon
műveleteket lehet végezni. Az objektumok négy fontos elvet követnek:</p>
<dl><dt>Egységbezárás (encapsulation)</dt><dd>Az objektum és a műveletei
olyan formában jelennek meg a nyelvben, hogy szintaktikailag egységet
alkotnak. Ez a gyakorlatban azt jelenti, hogy az osztályoknak (és a
struktúráknak) tagfüggvényei lehetnek, amik megvalósítják a műveleteket.</dd>
<dt>Adatrejtés (information hiding)</dt><dd>Az objektum belső állapota nem
érhető el közvetlenül. Pl. a dinamikus tömb hosszához nem férhet hozzá
mezőnhivatkozáson keresztül, csak művelettel kérheti le és állíthatja, így a
dinamikus tömb megvalósíthatja az automatikus újraallokálást.</dd>
<dt>Öröklés (inheritance)</dt><dd>Az objektumok osztálya van, az osztályok
pedig más osztályokat bővíthetnek (&bdquo;örökölhetnek&rdquo; &ndash; nem
szeretem ezt a szóhasználatot, helyette rendre a &bdquo;bővített&rdquo; szót
fogom használni). Pl. a <code class="sh_cpp">Bicycle</code> egy bicikli adatait tárolja el (pl.
kerékátmérő és sebességek száma). Viszont biciklitől függően lehet, hogy
további adatokat akarunk megadni, pl. városi kerékpár (<code
class="sh_cpp">CityBike</code>) esetén a kosár
űrtartalmát. Nem kell újra megírnunk azt a függvényt, ami a kerék
fordulatszámából (a kerékátmérő ismeretében) a bicikli sebességét
kiszámolja, hiszen az ugyanaz a városi kerékpárra, mint bármely más
kerékpárra. A leszármazott osztályok új mezőkkel és függvényekkel bővíthetik
az ősosztályt, valamint az arra megjelölt függvényeket akár le is
cserélhetik.</dd>
<dt>Behelyettesíthetőség</dt><dd>Az osztályok bővítései behelyettesíthetővé
válnak oda, ahol a bővített osztályba (&bdquo;szülőosztályba&rdquo;) tartozó
objektum szerepelhet. Pl. ha egy függvény <code
class="sh_cpp">Bicycle*</code> vagy <code class="sh_cpp">Bicycle&amp;</code>
típusú paramétert vár, ott rendre <code class="sh_cpp">CityBike*</code> és <code
class="sh_cpp">CityBike&amp;</code> típusú érték is megadható.</dd>
<dt>Típustámogatás (extra, csak C++-ra és egy pár más nyelvre igaz)</dt><dd>Az
osztályok ugyanúgy működhetnek, mint a beépített típusok. Vagyis a
<code>Complex</code> osztály ugyanúgy működhet, mint a <code
class="sh_cpp">float</code> vagy a <code>double</code>.</dd>
</dl>
<h2>Osztályok a C++-ban</h2>
<pre class="sh_cpp" data-source="oo/point.h"></pre>
<p>A <code class="sh_cpp">class</code> abban különbözik a <code
class="sh_cpp">struct</code>-tól, hogy az alapértelmezett láthatóság <code
class="sh_cpp">private</code>. Háromféle láthatósági szint létezik:</p>
<ul>
<li><code class="sh_cpp">private:</code> csak az osztály látja</li>
<li><code class="sh_cpp">protected:</code> a bővíett osztályok (gyermekosztályok) is látják</li>
<li><code class="sh_cpp">public:</code> mindenki látja</li>
</ul>
<pre class="sh_cpp" data-source="oo/point.cc"></pre>
<pre class="sh_cpp" data-source="oo/first.cc"></pre>
<pre class="console" data-source="oo/first.txt"></pre>
<p>Figyeljük meg, hogy a destruktorokat fordított sorrendben hívja meg,
amikor az objektum kikerül a scope-ból.</p>
<p>Nagyon fontos, hogy a konstruktorokat nem hívjuk meg sehol. A fordító nem
fog szólni miatta, de ettől helytelen gyakorlat. Inkább hozzunk létre egy
függvényt, amit a konstruktor és a konstruktort hívó függvény meghív.</p>
<p>A destruktort sem hívjuk meg kézzel.</p>
<p>A <code>Point</code> osztálynak nincs paraméter nélküli, azaz
alapértelmezett konstruktora. Ezért az alábbi nem fordul:</p>
<pre class="sh_cpp" data-source="oo/nodefault.cc"></pre>
<pre class="console" data-source="oo/nodefault.txt"></pre>
<h2>A <code class="sh_cpp">new</code> kulcsszó</h2>
<p>A C++ a memóriaallokációt nyelvi szinten tartalmazza. Allokálni a <ocde
class="sh_cpp">new</code> operátorral lehet, felszabadítani a <code
class="sh_cpp">delete</code> illetve a <code class="sh_cpp">delete[]</code>
operátorral. Az utóbbit abban az esetben kell alkalmazni, ha tömböt
szeretnénk felszabadítani. A C-vel ellentétben a memóriaallokáció mindig
típusos:</p>
<pre class="sh_cpp" data-source="oo/new.cc"></pre>
<p>Fontos megjegyezni, hogy az így létrehozott objektumok destruktorait nem a
scope-ból való kikerülésükkor, hanem a <code class="sh_cpp">delete</code>/<code
class="sh_cpp">delete[]</code> meghívásakor hívja meg automatikusan.</p>
<p>A <code class="sh_cpp">malloc</code> hívással ellentétben ez meghívja a
konstruktort is, még akkor is, ha tömböt allokálunk:</p>
<pre class="sh_cpp" data-source="oo/counter.h"></pre>
<pre class="sh_cpp" data-source="oo/counter.cc"></pre>
<pre class="sh_cpp" data-source="oo/second.cc"></pre>
<p>Jól látható, hogy a tömböt visszafelé szabadítja fel:</p>
<pre class="console" data-source="oo/second.txt"></pre>
<h2>A másoló konstruktor</h2>
<p>A Point osztályunknak van egy rejtett konstruktora. A tagfüggvény
<em>szignatúrája</em> valahogy így néz ki:</p>
<pre class="sh_cpp">Point::Point(const Point &amp;point);</pre>
<p>Ezt a fordító automatikusan generálta: egyszerűen minden mezőt lemásol.</p>
<pre class="sh_cpp" data-source="oo/third.cc"></pre>
<p>A változódeklarációnál leírt <code class="sh_cpp">=</code> nem ugyanaz,
mint az <code class="sh_cpp">=</code> művelet.</p>
<p>A másoló konstruktort testre is szabhatjuk, és ez néha szükséges is. Az
alábbi <code class="sh_cpp">StringBuffer</code> osztály egy karaktertömböt
allokál. Ha nem bíráljuk felül a másoló konstruktort, akkor egy az egyben
átveszi a mutatót a másik objektumból, és amelyiknek a destruktorát
másodjára hívja meg, az már felszabadított területre próbálja meghívni a
<code class="sh_cpp">delete</code>-et.</p>
<pre class="sh_cpp" data-source="oo/stringbuffer.h"></pre>
<pre class="sh_cpp" data-source="oo/stringbuffer.cc"></pre>
<p>A <code class="sh_cpp">this</code> mindig az aktuális objektumra mutat.
Akkor használjuk, ha az aktuális objektumunkra kell egy mutató (meglepő
módon), vagy egy olyan mezőt akarunk elérni, aminek a nevét elfedi egy
lokális változó. Vagy azért, mert ilyen hülye szokásunk van.</p>
</section>
</article>
<script type="application/javascript" src="js/sh_cpp.js"></script>
<script type="application/javascript" src="js/sh_main.js"></script>
<script type="application/javascript" src="http://ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
<script type="application/javascript" src="js/highlightDocument.js"></script>
</body>
</html>
