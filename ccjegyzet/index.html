<!DOCTYPE html>
<html lang="hu">
<head>
<meta charset="UTF-8"/>
<title>C++ jegyzet</title>
<link rel="stylesheet" href="css/sh_style.css"/>
<link rel="stylesheet" href="css/notes.css"/>
<meta name="viewport" content="width=device-width, user-scalable=no"/>
</head>
<body>
<ol>
<li><a href="#compiling">Fordítás</a></li>
<li><a href="#newLanguageElements">Új nyelvi elemek</a></li>
<li><a href="#oo">Objektum-orientált fejlesztés</a></li>
<li><a href="#oocc">Osztályok C++-ban</a></li>
<li><a href="#staticAndNamespaces">Statikus deklarációk és névterek</a></li>
<li><a href="#ccio">C++ I/O</a></li>
<li><a href="#opover">Operátor túlterhelés</a></li>
<li><a href="#extend">Osztály bővítés C++-ban</a></li>
<li><a href="#trycatch">Kivételkezelés</a></li>
<li><a href="#templates">Sablonok</a></li>
</ol>
<article>
<section id="compiling">
<h1>Fordítás</h1>
<p>A futtatható állomány előállítása három lépésből áll: preprocesszálás
&rarr; fordítás &rarr; összeállítás (preprocessor &rarr; compiler &rarr;
linker).</p>
<h2>Preprocesszálás</h2>
<p>A preprocesszálás végeredménye ritkán jelenik meg külön állományként, a
fordítás részeként fut le.</p>
<pre class="sh_cpp" data-source="preproctest/preproctest.cc"></pre>
<pre class="sh_cpp" data-source="preproctest/some_header.h"></pre>
<p>Ha azt akarjuk, hogy a fordító csak preprocesszáljon, akkor a
<code>-E</code>
kapcsolót kell használnunk gcc vagy clang esetén. Ekkor a stdoutra kiírja
azt, ami egyébként a fordítónak ment volna. Ha a kimenetet megnézzük, az
include egyszerűen csak beilleszti a megadott állományt a forrásba, ezen
kívül belekerül pár különös jel, ezekkel tud a fordító a hibakijelzésnél
az eredeti források soraira hivatkozni.</p>
<pre class="console" data-source="preproctest/output.txt"></pre>
<h2>Fordítás</h2>
<p>A fordítás során minden egyes <code>.cc</code>/<code>.cpp</code>
forrásból objektum állomány (<code>.o</code>/<code>.obj</code>) készül.
Az objektum állomány tartalmazza, a változók neveit, a függvények neveit
és gépi kódú forrását, valamint hogy ezek a függvények hol hivatkoznak meg
változókat és más függvényeket. Itt még nincs eldöntve, hogy a memóriában
hol fognak az egyes függvény kódok és globális változók elhelyezkedni.</p>
<p>A külső nevek típusának az ellenőrzése a fordító feladata, de ahhoz, hogy
ezt megtehesse, tudnia kell róla.</p>
<pre class="sh_cpp" data-source="refer1/refer1.cc"></pre>
<pre class="sh_cpp" data-source="refer1/util.cc"></pre>
<p>Ha azt akarjuk, hogy csak a preprocesszáló és a fordító fusson le,
használjuk a <code>-c</code> kapcsolót.</p>
<pre class="console" data-source="refer1/output.txt"></pre>
<p>A máshol definiált függvényeket és globális változókat deklarálni minden
egyes forrásban, ahol használni akarjuk komoly hibaforrás és rengeteg
pluszmunka, ezért szokás egy <code>.h</code> forrásba beletenni mindazon
változókat és függvényeket, amit egy másik modul számára elérhetővé akarunk
tenni. Ezt teszi minden egyes rendszerkönyvtár.</p>
<pre class="sh_cpp" data-source="refer2/refer2.cc"></pre>
<pre class="sh_cpp" data-source="refer2/util.h"></pre>
<pre class="sh_cpp" data-source="refer2/util.cc"></pre>
<pre class="console" data-source="refer2/output.txt"></pre>
<p>Előfordulhat, hogy a <code>util.h</code>-ban definiált
<code>Record</code> típust használja több modul is, pl. a függvények
paraméterlistájában. Elkerülhetetlen, hogy emiatt közvetve többször is
befűződjön a <code>util.h</code>. A típust újradeklarálni viszont nem
lehet.</p>
<pre class="sh_cpp" data-source="refer2/include.cc"></pre>
<pre class="console" data-source="refer2/include.txt"></pre>
<p>Ezért szokás a fejléceket makrókkal körülbástyázni, hogy ha újra
megjelennének egy fordítási egységben, akkor lényegében nem tartalmaznak
semmit.</p>
<pre class="sh_cpp" data-source="refer2/util_safe.h"></pre>
<p>A gyakorlatban minden népszerű fordító támogatja a nem szabványos
<code class="inline sh_cpp">#pragma once</code> direktívát, amivel ugyanezt
lehet <a href="http://en.wikipedia.org/wiki/Pragma_once">egyetlen plusz sorral
megvalósítani</a>. A vizsgán ne használd.</p>
<p>Minden olyan függvényt, amit nem használunk modulon kívüli használatra
érdemes úgy deklarálnunk, hogy azt más modulok még véletlenül se érhessék
el, hogy egy nagyobb program esetén ne érjenek kellemetlen meglepetések.
C-ben ezt a <code class="sh_cpp">static</code> kulcsszó használatával lehet elérni, C++-ban lehetőség
van <code class="sh_cpp">static</code> kulcsszót használni vagy névtelen névteret létrehozni (a
névterekről később).</p>
<pre class="sh_cpp" data-source="refer3/util.cc"></pre>
<pre class="sh_cpp" data-source="refer3/refer3.cc"></pre>
<pre class="console" data-source="refer3/output.txt"></pre>
<p>A példában a <code>foo</code> változót megtalálta, de a <code>bar</code>t
nem.</p>
<h2>Összeállítás</h2>
<p>A linker feladata, hogy eldöntse, hogy futás során hol fognak
elhelyezkedni a memóriában a globális változók és a függvények gépi kódja,
és hogy ez utóbbiak a már megállapított címen keressék őket.</p>
<p>Nagyon fontos tudni, hogy a linkerben a C++ már díszített (decorated)
neveket használ, ellentétben a C-vel, mert C++-ban már nem elég pusztán a
függvény nevét tudni a beazonosításhoz.</p>
<pre class="sh_cpp" data-source="link1/util.c"></pre>
<pre class="sh_cpp" data-source="link1/link1.cc"></pre>
<pre class="console" data-source="link1/output.txt"></pre>
<p>A C++ kód nem látta azt a C függvényt, amelyiket nem <code
class="sh_cpp">extern "C"</code> kulcsszóval deklaráltunk, illetve a C kód
nem látta azt a C++ függvényt, amit nem ezzel a kulcsszóval definiáltunk.</p>
<p>Az <code class="sh_cpp">extern "C"</code> lényegében azt mondja: &bdquo;erre a
deklarációra vagy definícióra ne használj díszített neveket!&rdquo; Van
<code class="sh_cpp">extern "C" { /* ... */ }</code> formája is, amivel
egyszerre több deklarációra vagy definícióra lehet ezt a módot beállítani.
Elsősorban C rutinkönyvtárak fejléceiben találkozni vele:</p>
<pre class="sh_cpp">#ifdef __cplusplus
extern "C" {
#endif

/* ... */

#ifdef __cplusplus
}
#endif</pre>
</section>
<section id="newLanguageElements">
<h1>Új nyelvi elemek</h1>
<h2>A <code class="sh_cpp">const</code> kulcsszó</h2>
<p>Előnyei:</p>
<ul>
<li>Ha átadok egy mutatót egy függvénynek, biztos lehetek, hogy nem fog a
tartalma változni, és a fordítót is biztosítom erről: ennek megfelelően
optimizálhatja a kódot</li>
<li>Elegánsabban lehet vele konstanst definiálni, mint a <code
class="sh_cpp">#define</code> direktívával: a konstansnak lesz típusa, és
lehet címe (a prefix &amp; operátorral)</li>
</ul>
<pre class="sh_cpp" data-source="new/const.cc"></pre>
<pre class="console" data-source="new/const.txt"></pre>
<h2>Egyszerűbb függvény deklaráció</h2>
<p>C-ben a <code class="sh_cpp">int main()</code> <code class="sh_cpp">int
main(...)</code>-nak felelt meg, a paraméter nélküli függvényeket <code
class="sh_cpp">int main(void)</code>-ként kellett deklarálni. C++-ban ez már
nem érvényes, a <code class="sh_cpp">int main()</code> ekvivalens a <code
class="sh_cpp">int main(void)</code> deklarációval.</p>
<h2>Változó deklaráció bárhol</h2>
<p>Bárhol lehet változót deklarálni, nem csak a blokkok elején és a
for ciklusokban.</p>
<pre class="sh_cpp" data-source="new/decl.cc"></pre>
<h2>Függvények túlterhelése</h2>
<p>A függvényeket már nem csak a nevük, hanem a paraméterlistájuk is
azonosítja, amíg egyértelmű.</p>
<pre class="sh_cpp" data-source="new/overload.cc"></pre>
<pre class="console" data-source="new/overload.txt"></pre>
<p>Többek között emiatt van szükség az <code class="sh_cpp">extern "C"</code>
módosítóra.</p>
<h2>Függvény paraméter alapértelmezett értékek</h2>
<p>A függvény utolsó paramétereinek adhatunk alapértelmezett értéket, ezzel
azok a paraméterek elhagyhatóvá válnak. Paramétereket elhagyni csak a
függvény végéről lehet, nem lehet pl. a harmadikat elhagyni, a negyediket
viszont megadni.</p>
<pre class="sh_cpp" data-source="new/default.cc"></pre>
<pre class="console" data-source="new/default.txt"></pre>
<h2>Referenciák</h2>
<p>Mutatók mellett referenciákat is használhatunk. A háttérben ezek is
mutatók, de nem tudjuk a mutató értékét megváltoztatni, csak azt az értéket,
amire mutat.</p><p>Ha a referenciát const kulcsszóval deklaráljuk, a fordító
képes automatikusan ideiglenes változót létrehozni, ha kell (lásd a példát).
Ha azonban a visszatérési érték referencia, akkor a biztonságos működéshez
csak olyan referenciát adhatunk vissza, ami nincs a függvény élettartamához
kötve. Ha mégis megtesszük, a program még le is fordulhat, de nem várt
eredményeket produkálhat.</p>
<pre class="sh_cpp" data-source="new/ref.cc"></pre>
<pre class="console" data-source="new/ref.txt"></pre>
<h2><code class="sh_cpp">inline</code> függvények</h2>
<p>A <code class="sh_cpp">#define</code> direktívával létrehozott
makró-függvényeknek kellemetlen mellékhatásai lehetnek:</p>
<pre class="sh_cpp">#define MUL(a, b) a*b
// ...
#define SIX 1+5
#define NINE 8+1
int val = MUL(SIX, NINE);
// val erteke 42 (nem 54)</pre>
<p>Zárójelezéssel javíthatunk rajta, a deklaráció nem lett szebb, és még így
is problémáink akadhatnak:</p>
<pre class="sh_cpp">#define MAX(a, b) ((a)>(b)?(a):(b))
// ...
int a = 6;
int b = 5;
int val = MAX(++a, b);
// a es val erteke mar 8</pre>
<p>Ezen kívül ha makrókat használunk, nincsenek típusdeklarációk,
nem lehet használni a túlterhelést, az alapértelmezett értékeket,
és egyebeket, amikről eddig nem volt szó. De szeretnénk, ha nem
hajtana végre külön függvényhívást, ha a fordító is úgy gondolja,
hogy ez kézenfekvő.</p>
<pre class="sh_cpp">inline int max(int a, int b)
{
    return a > b ? a : b;
}
// ...
int a = 6;
int b = 5;
int val = max(++a, b);
// a es val erteke 7</pre>
<p>A fordító nem veszi figyelembe az <code class="sh_cpp">inline</code>
kulcsszót, ha</p>
<ul>
<li>a függvénynek címét vesszük, és azzal hívjuk meg (elvileg közvetlen
meghívásnál még mindig befűzheti a hívás helyett)</li>
<li>a függvény rekurzív</li>
<li>a függvény túl bonyolult vagy nagy</li>
<li>fordító hóbortból</li>
</ul>
<h2>Implicit <code class="sh_cpp">typedef</code> struktúrákra</h2>
<p>A struktúrákra nem kell ezentúl <code class="sh_cpp">struct
StrukturaNev</code> formában hivatkozni, simán <code
class="sh_cpp">StrukturaNev</code> is megteszi.</p>
<pre class="sh_cpp">struct Rect {
    int x, y;
    int width, height;
};

// OK
struct Rect rect1;

// C++-ban mar ez is OK
Rect rect2;</pre>
</section>
<section id="oo">
<h1>Objektum-orientált fejlesztés</h1>
<p>Az OOP lényege, hogy objektumokkal dolgozunk. Objektum lehet pl. egy
komplex szám, egy dinamikus tömb vagy egy gomb a képernyőn. Az objektumokon
műveleteket lehet végezni. Az objektumok négy fontos elvet követnek:</p>
<dl><dt>Egységbezárás (encapsulation)</dt><dd>Az objektum és a műveletei
olyan formában jelennek meg a nyelvben, hogy szintaktikailag egységet
alkotnak. Ez a gyakorlatban azt jelenti, hogy az osztályoknak (és a
struktúráknak) tagfüggvényei lehetnek, amik megvalósítják a műveleteket.</dd>
<dt>Adatrejtés (information hiding)</dt><dd>Az objektum belső állapota nem
érhető el közvetlenül. Pl. a dinamikus tömb hosszához nem férhet hozzá
mezőnhivatkozáson keresztül, csak művelettel kérheti le és állíthatja, így a
dinamikus tömb megvalósíthatja az automatikus újraallokálást.</dd>
<dt>Öröklés (inheritance)</dt><dd>Az objektumok osztálya van, az osztályok
pedig más osztályokat bővíthetnek (&bdquo;örökölhetnek&rdquo; &ndash; nem
szeretem ezt a szóhasználatot, helyette rendre a &bdquo;bővített&rdquo; szót
fogom használni). Pl. a <code class="sh_cpp">Bicycle</code> egy bicikli adatait tárolja el (pl.
kerékátmérő és sebességek száma). Viszont biciklitől függően lehet, hogy
további adatokat akarunk megadni, pl. városi kerékpár (<code
class="sh_cpp">CityBike</code>) esetén a kosár
űrtartalmát. Nem kell újra megírnunk azt a függvényt, ami a kerék
fordulatszámából (a kerékátmérő ismeretében) a bicikli sebességét
kiszámolja, hiszen az ugyanaz a városi kerékpárra, mint bármely más
kerékpárra. A leszármazott osztályok új mezőkkel és függvényekkel bővíthetik
az ősosztályt, valamint az arra megjelölt függvényeket akár le is
cserélhetik.</dd>
<dt>Behelyettesíthetőség</dt><dd>Az osztályok bővítései behelyettesíthetővé
válnak oda, ahol a bővített osztályba (&bdquo;szülőosztályba&rdquo;) tartozó
objektum szerepelhet. Pl. ha egy függvény <code
class="sh_cpp">Bicycle*</code> vagy <code class="sh_cpp">Bicycle&amp;</code>
típusú paramétert vár, ott rendre <code class="sh_cpp">CityBike*</code> és <code
class="sh_cpp">CityBike&amp;</code> típusú érték is megadható.</dd>
<dt>Típustámogatás (extra, csak C++-ra és egy pár más nyelvre igaz)</dt><dd>Az
osztályok ugyanúgy működhetnek, mint a beépített típusok. Vagyis a
<code>Complex</code> osztály ugyanúgy működhet, mint a <code
class="sh_cpp">float</code> vagy a <code>double</code>.</dd>
</dl>
</section>
<section id="oocc">
<h1>Osztályok C++-ban</h1>
<pre class="sh_cpp" data-source="oo/point.h"></pre>
<p>A <code class="sh_cpp">class</code> abban különbözik a <code
class="sh_cpp">struct</code>-tól, hogy az alapértelmezett láthatóság <code
class="sh_cpp">private</code>. Háromféle láthatósági szint létezik:</p>
<ul>
<li><code class="sh_cpp">private:</code> csak az osztály látja</li>
<li><code class="sh_cpp">protected:</code> a bővíett osztályok (gyermekosztályok) is látják</li>
<li><code class="sh_cpp">public:</code> mindenki látja</li>
</ul>
<pre class="sh_cpp" data-source="oo/point.cc"></pre>
<pre class="sh_cpp" data-source="oo/first.cc"></pre>
<pre class="console" data-source="oo/first.txt"></pre>
<p>Figyeljük meg, hogy a destruktorokat fordított sorrendben hívja meg,
amikor az objektum kikerül a scope-ból.</p>
<p>Nagyon fontos, hogy a konstruktorokat nem hívjuk meg sehol. A fordító nem
fog szólni miatta, de ettől helytelen gyakorlat. Inkább hozzunk létre egy
függvényt, amit a konstruktor és a konstruktort hívó függvény meghív.</p>
<p>A destruktort sem hívjuk meg kézzel.</p>
<p>A <code>Point</code> osztálynak nincs paraméter nélküli, azaz
alapértelmezett konstruktora. Ezért az alábbi nem fordul:</p>
<pre class="sh_cpp" data-source="oo/nodefault.cc"></pre>
<pre class="console" data-source="oo/nodefault.txt"></pre>
<h2>A <code class="sh_cpp">new</code> és a <code
class="sh_cpp">delete</code> kulcsszó</h2>
<p>A C++ a memóriaallokációt nyelvi szinten tartalmazza. Allokálni a <ocde
class="sh_cpp">new</code> operátorral lehet, felszabadítani a <code
class="sh_cpp">delete</code> illetve a <code class="sh_cpp">delete[]</code>
operátorral. Az utóbbit abban az esetben kell alkalmazni, ha tömböt
szeretnénk felszabadítani. A C-vel ellentétben a memóriaallokáció mindig
típusos:</p>
<pre class="sh_cpp" data-source="oo/new.cc"></pre>
<p>Fontos megjegyezni, hogy az így létrehozott objektumok destruktorait nem a
scope-ból való kikerülésükkor, hanem a <code class="sh_cpp">delete</code>/<code
class="sh_cpp">delete[]</code> meghívásakor hívja meg automatikusan.</p>
<p>A <code class="sh_cpp">malloc</code> hívással ellentétben ez meghívja a
konstruktort is, még akkor is, ha tömböt allokálunk:</p>
<pre class="sh_cpp" data-source="oo/counter.h"></pre>
<pre class="sh_cpp" data-source="oo/counter.cc"></pre>
<pre class="sh_cpp" data-source="oo/second.cc"></pre>
<p>Jól látható, hogy a tömböt visszafelé szabadítja fel:</p>
<pre class="console" data-source="oo/second.txt"></pre>
<h2>A másoló konstruktor</h2>
<p>A Point osztályunknak van egy rejtett konstruktora. A tagfüggvény
<em>szignatúrája</em> valahogy így néz ki:</p>
<pre class="sh_cpp">Point::Point(const Point &amp;point);</pre>
<p>Ezt a fordító automatikusan generálta: egyszerűen minden mezőt lemásol.</p>
<pre class="sh_cpp" data-source="oo/third.cc"></pre>
<p>A változódeklarációnál leírt <code class="sh_cpp">=</code> nem ugyanaz,
mint az <code class="sh_cpp">=</code> művelet.</p>
<p>A másoló konstruktort testre is szabhatjuk, és ez néha szükséges is. Az
alábbi <code class="sh_cpp">StringBuffer</code> osztály egy karaktertömböt
allokál. Ha nem bíráljuk felül a másoló konstruktort, akkor egy az egyben
átveszi a mutatót a másik objektumból, és amelyiknek a destruktorát
másodjára hívja meg, az már felszabadított területre próbálja meghívni a
<code class="sh_cpp">delete</code>-et.</p>
<pre class="sh_cpp" data-source="oo/stringbuffer.h"></pre>
<pre class="sh_cpp" data-source="oo/stringbuffer.cc"></pre>
<p>A <code class="sh_cpp">this</code> mindig az aktuális objektumra mutat.
Akkor használjuk, ha az aktuális objektumunkra kell egy mutató (meglepő
módon), vagy egy olyan mezőt akarunk elérni, aminek a nevét elfedi egy
lokális változó. Vagy azért, mert ilyen hülye szokásunk van.</p>
</section>
<section id="staticAndNamespaces">
<h1>Statikus deklarációk és névterek</h1>
<h2>A <code class="sh_cpp">static</code> kulcsszó függvényekben</h2>
<p>A <code class="sh_cpp">static</code> kulcsszó C-ben és C++-ban egyaránt
rendelkezésre áll függvényeken belül is:
</p>
<pre class="sh_cpp">void foo()
{
    static int count = 0;
    printf("%d\n", ++count);
}</pre>
<p>Az ilyen statikus változók inicializálója csak egyszer hívódik meg, és
hívásról hívásra megőrzi az értékét, pont mint egy globális változó. A
globális változóval ellentétben viszont nem érhető el, csak a függvényen
belülről.</p>
<h2>A <code class="sh_cpp">static</code> kulcsszó osztályokban</h2>
<p>Az osztályhoz kötött statikus mezők és függvények szintén globális
változóként működnek, azaz nem kötöttek objektum példányhoz, a láthatóságuk
pedig a <code class="sh_cpp">public</code>/<code class="sh_cpp">protected</code>/<code
class="sh_cpp">private</code> elérési sémákkal szabályozhatók.</p>
<pre class="sh_cpp" data-source="vis/stat.cc"></pre>
<pre class="console" data-source="vis/stat.txt"></pre>
<p>Figyeljük meg, hogy a statikus mező deklaráció egy <code
class="sh_cpp">extern</code> változódeklarációval egyenértékű, vagyis a változót
még külön egyszer deklarálni kell, ahol egyébként a kezdőérték is megadható.
Megosztott komponenseknél ezt az osztály implementációját tartalmazó forrásba célszerű
tenni.</p>
<h2>A <code class="sh_cpp">friend</code> kulcsszó</h2>
<p>A <code class="sh_cpp">friend</code> kulcsszóval hozzáférést adhatunk az
osztály <code class="sh_cpp">protected</code> és <code
class="sh_cpp">private</code> mezőihez más függvények és osztályok számára
(ez esetben az osztály valamennyi tagfüggvénye hozzáférhet a mezőkhöz).
A friend deklarációt az osztályon belül bárhova írhatjuk, minden esetben
ugyanazt jelenti.</p>
<pre class="sh_cpp" data-source="vis/friend.cc"></pre>
<h2>Névterek</h2>
<p>Más nyelvekben, ahol nincs lehetőség globális változókat vagy
függvényeket deklarálni, előfordul, hogy az összetartozó konstansokat,
függvényeket vagy globális változókat egy osztályban deklarálják statikus
elemekként. Ami szép, mert az összetartozó elemeket egybefogja, és csúnya,
mert mindezt osztályokkal teszi. C++-ban erre nincs szükség: használhatjuk a
<code class="sh_cpp">namespace</code> kulcsszót.</p>
<pre class="sh_cpp" data-source="vis/ns.cc"></pre>
<pre class="console" data-source="vis/ns.txt"></pre>
<p>Figyeljük meg, hogy a show függvényben (illetve bármely deklarációban a
névteren belül) a névtér saját változóit részesíti előnyben. A névtér
nélküli globális változókat elérni a négyesponttal tudja. A négyesponttal
kezdődő minősített neveknél a névtereket teljesen kézzel adjuk meg. Az
alábbi példa &ndash; bár nem szép &ndash; demonstrálja, hol lehet ez
szükséges:</p>
<pre class="sh_cpp" data-source="vis/badns.cc"></pre>
<pre class="console" data-source="vis/badns.txt"></pre>
<p>C++-ban minden standard C könyvtárnak megtalálható a C++ verziója, ami
annyiban különbözik, hogy a rendszerhívások belekerülnek a std névtérbe. A
header nevét a &bdquo;.h&rdquo; elhagyásával és a &bdquo;c&rdquo; előtag
hozzáadásával kapjuk meg.</p>
<p>Globális statikus változók és függvények (vagyis amik csak az adott
fordítási egységben láthatók) üres névtérrel is deklarálhatók:</p>
<pre class="sh_cpp">namespace
{
    // mas forditasi egysegbol nem lathato,
    // pont mint a static kulcsszoval
    int lokalis = 1;
}</pre>
<p>Névterekben található változók és függvények semmilyen formában nem
oszthatóak meg C modulokkal.</p>
<h2>A <code class="sh_cpp">using</code> kulcsszó</h2>
<p>A <code class="sh_cpp">using</code> kulcsszó használatával
egyszerűsíthetjük a névterekben lévő elemek elérését. A deklaráció mindig a
fordítási egységre vonatkozik, vagyis header esetén minden C++ forrásra
érvényes lesz, amelyik a headert befűzi, ezért headerbe ilyet írni nem szép
dolog. A <code class="sh_cpp">using</code> önmagában egyetlen nevet tesz
elérhetővé a névtér megadása nélkül. A <code class="sh_cpp">using
namespace</code> a névtér valamennyi elemét elérhetővé teszi a
névtérmegjelölés (kvalifikáció) nélkül.</p>
<pre class="sh_cpp" data-source="oo/using.cc"></pre>
</section>
<section id="ccio">
<h1>C++ I/O</h1>
<h2>Folyamok (streamek)</h2>
<p>Ahogyan a C-s szöveges I/O legtöbbet használt része a formátum stirng,
úgy a C++ I/O alapja a stream. A <code class="sh_cpp">stdout</code> C++-ban a <code
class="sh_cpp">std::cout</code>, a <code class="sh_cpp">stderr</code> pedig a
<code class="sh_cpp">std::cerr</code>.</p>
<p>Az elmaradhatatlan &bdquo;Hello World!&rdquo; alkalmazás:</p>
<pre class="sh_cpp" data-source="io/hello.cc"></pre>
<p>A <code class="sh_cpp">std::endl</code> azon kívül, hogy kiír egy
soremelés karaktert, üríti a buffert is: a karaktereket ugyanis a rendszer nem
egyenként szokta a rendszer a képernyőre írni, hanem kötegelve (ez C-ben sem
volt másképp, legfeljebb nem tudtatok róla :D).</p>
<p>A <code class="sh_cpp">std::cout</code>-hoz hasonlóan van <code
class="sh_cpp">std::cin</code> is:</p>
<pre class="sh_cpp" data-source="io/circumference.cc"></pre>
<p>A program beolvassa a radius változóba a <code>stdin</code>ről egy tört
értéket, majd kiszámolja a kör kerületét és kiírja.</p>
<p>Figyeljük meg, hogy a shift operátor nyilai a kimenetnél a kimenet felé
mutatnak, a bemenetnél pedig onnan indulnak ki (hogy miért tud a shift
operátor ilyen különösen viselkedni, arról később lesz szó).</p>
<h2>Írás állományokba</h2>
<p>Az <code class="sh_cpp">ifstream</code> és az <code
class="sh_cpp">ofstream</code> osztályokkal történik. Szöveges formázott elérés:</p>
<pre class="sh_cpp" data-source="io/distance.cc"></pre>
<pre class="console" data-source="io/coords.txt"></pre>
<pre class="console" data-source="io/distances.txt"></pre>
<p>Egyéb elérési módok (itt most ifstream és ofstream helyett a
szülőosztályt, az istreamet és az ostreamet használom):</p>
<pre class="sh_cpp" data-source="io/string.cc"></pre>
<pre class="console" data-source="io/string.txt"></pre>
<h2>Mezők formázása</h2>
<pre class="sh_cpp" data-source="io/format.cc"></pre>
<pre class="console" data-source="io/format.txt"></pre>
</section>
<section id="opover">
<h1>Operátor túlterhelés</h1>
<p>Operátorokat definiálhatunk olyan típusokra, amikre egyébként nincsenek.
Nem változtathatjuk meg az eredeti működést (vagy legalábbis nagyon nem
javaslom), nem változtathatjuk meg a
precedenciát, nem hozhatunk létre teljesen új operátorokat (pl. <code
class="sh_cpp">**</code>)</p>
<p>Az operátorok legalább egyik tagja osztály kell, hogy legyen.</p>
<pre class="sh_cpp" data-source="opover/complex.cc"></pre>
<pre class="console" data-source="opover/complex.txt"></pre>
<p>Figyeljük meg, milyen sorrendben értékeli ki őket:</p>
<pre class="sh_cpp" data-source="opover/order.cc"></pre> 
<pre class="console" data-source="opover/order.txt"></pre> 
<p>Kérdés még, hogy hogyan különböztetjük meg a prefix és a
posztfix <code class="sh_cpp">++</code> operátort.</p>
<pre class="sh_cpp">class A
{
    int val;
public:
    //
    // ...
    //
    
    // ++a
    A&amp; operator++()
    {
        ++val;
        return *this;
    }
    
    // a++
    A operator++(int)
    {
        // elmentjuk az eredeti erteket
        A result(*this);
        ++val;
        return result;
    }
    
    //
    // ...
    //
};</pre>
<p>A posztfix <code class="sh_cpp">++</code> és <code
class="sh_cpp">--</code> operátorhoz meg kell követelnünk egy extra <code
class="sh_cpp">int</code> paramétert, amit nem használunk fel.</p>
<h2>Típuskonverzió, mint operátor</h2>
<pre class="sh_cpp" data-source="opover/simplecomplex.cc"></pre>
<pre class="console" data-source="opover/simplecomplex.txt"></pre>
<p>Figyeljük meg, hogy a típuskonverziós operátoroknál hiányzik a
visszatérési érték típusa, mert azt az <code class="sh_cpp">operator</code>
kulcsszó után adjuk meg.</p>
<p>A függvényhívás operátor az egyetlen, amely tetszőleges számú paramétert
vehet fel. A példában nem ez szerepel, de pl. egy 0 paraméteres
függvényhívás operátort <code
class="sh_cpp">double operator()()</code> szignatúrával tagfüggvényként,
vagy <code class="sh_cpp">double operator()(Poly3 &amp;p)</code> kívülről.</p>
<pre class="sh_cpp" data-source="opover/poly3.cc"></pre>
<pre class="console" data-source="opover/poly3.txt"></pre>
<p>Az következő operátorok nem terhelhetőek túl: <code class="sh_cpp">. ::
?: sizeof</code>. Minden más igen, beleértve néhány különös megoldást is:</p>
<pre class="sh_cpp" data-source="opover/strange.cc"></pre>
<pre class="console" data-source="opover/strange.txt"></pre>
</section>
<section id="extend">
<h1>Osztály bővítés C++-ban</h1>
<p>Nézzünk először egy viszonylag egyszerű példát: dátum és idő. Az idő
napot is megjelöl, a dátum viszont csak napot:</p>
<pre class="sh_cpp" data-source="extend/date.h" id="date_h"></pre>
<p>A szülőosztály lehet rejtett, ilyenkor a következőképpen
alakul a mezőinek a láthatósága az új osztályban:</p>
<table>
<thead>
<tr><th>Szülőosztály:</th><th rowspan="2"><code
class="sh_cpp">public</code></th><th rowspan="2"><code
class="sh_cpp">protected</code></th><th rowspan="2"><code
class="sh_cpp">private</code></th></tr>
<tr><th>Mező:</th></tr>
</thead>
<tbody>
<tr>
    <th><code class="sh_cpp">public</code></th>
    <td><code class="sh_cpp">public</code></td>
    <td><code class="sh_cpp">protected</code></td>
    <td><code class="sh_cpp">private</code></td>
</tr>
<tr>
    <th><code class="sh_cpp">protected</code></th>
    <td><code class="sh_cpp">protected</code></td>
    <td><code class="sh_cpp">protected</code></td>
    <td><code class="sh_cpp">private</code></td>
</tr>
<tr>
    <th><code class="sh_cpp">private</code></th>
    <td><em>nem érhető el</em></td>
    <td><em>nem érhető el</em></td>
    <td><em>nem érhető el</em></td>
</tr>
</tbody>
</table>
<p>A táblázat alapján elmondhatjuk, hogy a szülőosztály láthatósági
megszorítása egy &bdquo;láthatósági plafont&rdquo; ad.</p>
<h2>Virtuális metódusok</h2>
<p>Az új osztály a bővítendő osztály függvényei helyett újakat definiálhat,
de ebből a szempontból meg kell különböztetnünk a virtuális és a hagyományos
függvényeket:</p>
<pre class="sh_cpp" data-source="extend/person.h" id="person_h"></pre>
<pre class="sh_cpp" data-source="extend/person.cc"></pre>
<pre class="sh_cpp" data-source="extend/employee.h" id="employee_h"></pre>
<pre class="sh_cpp" data-source="extend/employee.cc"></pre>
<pre class="sh_cpp" data-source="extend/extend.cc"></pre>
<pre class="console" data-source="extend/extend.txt"></pre>
<p>A virtuális függvény azt jelenti, hogy az osztályhoz tartozni fog egy
virtuális függvény tábla, amely az osztály virtuális függvényeinek címét
tartalmazza. Az objektumpéldány tartalmaz egy mutatót az osztály virtuális
függvény táblájára. Normális esetben a tagfüggvényeket úgy hívja meg, hogy
annak a címét fordítási időben a linker írja be. Virtuális függvény esetében
viszont az objektum egy rejtett mezőjéből kiolvassa a virtuális függvény
tábla címét, majd a tábla megfelelő elemét, amely tartalmazni fogja a
meghívott függvény címét.</p>
<p>Így amikor <code class="sh_cpp">Person&amp;</code>-ként hivatkoztunk az
<code class="sh_cpp">Employee</code> objektumra, a <code
class="sh_cpp">print()</code> függvény meghívásánál a <code
class="sh_cpp">Person</code> osztály <code
class="sh_cpp">print()</code> függvényét drótotza be még a linker, viszont a <code
class="sh_cpp">printVirtual()</code> esetén a referencia mögötti objektum
osztályától függ, hogy melyik függvényt hívja meg.</p>
<p>Ha valamelyik szülőosztályban egy függvény virtuálisként lett megjelölve, akkor
annak minden gyermekosztálybeli megfelelője implicit módon virtuális lesz, akár
kitesszük a <code class="sh_cpp">virtual</code> kulcsszót, akár nem. A kód
megértését segíti, ha kitesszük.</p>
<p>Mivel a virtuális függvény alapvető tulajdonsága, hogy címe van, <code
class="sh_cpp">inline</code> nem lehet.</p>
<h2>Virtuális destruktor</h2>
<p>A destruktor is lehet virtuális. Azt mondják ökölszabálynak: ha az
osztálynak van legalább egy virtuális metódusa, akkor a destruktornak is
virtuálisnak kell lennie. A valóság ennél árnyltabb:</p>
<pre class="sh_cpp" data-source="extend/vd.cc"></pre>
<pre class="console" data-source="extend/vd.txt"></pre>
<p>Figyeljük meg, hogy az első esetet leszámítva &ndash; helyesen &ndash;
mindkét destruktor lefutott. Az első esetben a delete művelet során azonban,
megnézte, mivel van dolga: <code class="sh_cpp">SDA*</code>,
<em>meghívta</em> a destruktorát, és felszabadította a területet. Az utolsó
esetben megnézte, mivel van dolga: <code class="sh_cpp">VDA*</code>,
<em>meghívta</em> a destruktorát, és felszabadította a területet. Volt
azonban egy fontos különbség: az előbbi esetben kifejezetten az <code
class="sh_cpp">SDA::~SDA()</code> destruktort hívta meg, míg az utóbbi
esetben a meghívandó függvény címét a virtuális metódustáblából nézte ki,
így végül a <code class="sh_cpp">VDB::~VDB()</code> függvény lefuttatására
került sor.</p>
<h2>Absztrakt osztályok és metódusok</h2>
<p>A virtuális függvények lehetnek absztrakt metódusok, ami azt jelenti,
hogy az adott osztályban nem tartozik hozzá implementáció.</p>
<pre class="sh_cpp" data-source="extend/abstract.cc"></pre>
<pre class="console" data-source="extend/abstract.txt"></pre>
<p>Ha az osztálynak van absztrakt függvénye, nem példányosítható:</p>
<pre class="console" data-source="extend/abstractInstance.txt"></pre>
<h2>Többszörös öröklés</h2>
<p>A <code class="sh_cpp">Stingifiable</code> megfelelő azoknak az
osztályoknak, amelyek értelmesen szöveggé alakíthatóak, de mi van azokkal,
amik egész számmá is alakíthatóak? A felvázolt <code
class="sh_cpp">Number</code> osztálynál egyértelmű, mit kell tenni, de egy
komplex típusnál vehetnénk pl. a valós rész egészrészét. De mindkettőről
tudjuk, hogy kiválóan átalakíthatóak szöveggé is. Itt jön be a többszörös
öröklés:</p>
<pre class="sh_cpp" data-source="extend/multi.cc" id="multi_cc"></pre>
<p>A többszörös öröklés nem csak absztrakt szülőosztályokra vonatkozik,
teljes értékű osztályok is lehetnek szülőosztályok többszörös öröklésnél is.</p>
<h2>Virtuális szülőosztályok</h2>
<p>Nézzünk egy másik példát, ahol egy klub csoportvezetőit és csoporttagjait
tartjuk számon. Azonban a klub vezetőjét leszámítva mindenki tagja a
csoportvezetők csoportjának, vagyis egyszerre csoporttagok és
csoportvezetők.</p>
<pre class="sh_cpp" data-source="extend/wrongHierarchy.h"></pre>
<p>Első ránézésre jónak néz ki. Próbáljuk ki:</p>
<pre class="sh_cpp" data-source="extend/wrongHierarchy.cc"></pre>
<pre class="console" data-source="extend/wrongHierarchy.txt"></pre>
<p>A fordítás sajnos elszállt. Nézzük meg, hogyan néznek ki az egyes osztályok
példányai a memóriában, de először csak egy egyszerű példára, a már
felvázolt <a href="#date_h"><code class="sh_cpp">Date</code></a>-re:</p>
<div class="memoryLayoutSet">
    <div class="memoryLayout">
        <table>
        <thead><tr><th>Date</th></tr></thead>
        <tbody>
        <tr><td class="sh_cpp">int year;</td></tr>
        <tr><td class="sh_cpp">int month;</td></tr>
        <tr><td class="sh_cpp">int day;</td></tr>
        </tbody>
        </table>
    </div>
    <div class="memoryLayout">
        <table>
        <thead><tr><th>DateTime</th></tr></thead>
        <tbody class="inherited">
        <tr><td class="sh_cpp">int year;</td></tr>
        <tr><td class="sh_cpp">int month;</td></tr>
        <tr><td class="sh_cpp">int day;</td></tr>
        </tbody>
        <tbody>
        <tr><td class="sh_cpp">int hour;</td></tr>
        <tr><td class="sh_cpp">int minute;</td></tr>
        <tr><td class="sh_cpp">int second;</td></tr>
        </tbody>
        </table>
    </div>
</div>
<p>Ha egy <code class="sh_cpp">DateTime</code> típusú objektumra úgy
tekintünk, mint egy <code class="sh_cpp">Date</code> típusúra, akkor
azt látjuk, amire számítunk: évet, hónapot, napot, egy-egy <code
class="sh_cpp">int</code>-ként, egymás után.</p>
<p>Nézzük az egyszerű, virtuális metódusos öröklést a <a href="#person_h"><code
class="sh_cpp">Person</code></a> és az <a href="#employee_h"><code
class="sh_cpp">Employee</code></a> osztályokra:</p>
<div class="memoryLayoutSet">
    <div class="memoryLayout">
        <table>
        <thead><tr><th>Person</th></tr></thead>
        <tbody>
        <tr><td class="sh_cpp">void *vtable;</td></tr>
        <tr><td class="sh_cpp">std::string name;</td></tr>
        <tr><td class="sh_cpp">Date birthDate;</td></tr>
        </tbody>
        </table>
    </div>
    <div class="memoryLayout">
        <table>
        <thead><tr><th>Employee</th></tr></thead>
        <tbody>
        <tr><td class="sh_cpp">void *vtable;</td></tr>
        </tbody>
        <tbody class="inherited">
        <tr><td class="sh_cpp">std::string name;</td></tr>
        <tr><td class="sh_cpp">Date birthDate;</td></tr>
        </tbody>
        <tbody>
        <tr><td class="sh_cpp">Date hiringDate;</td></tr>
        </tbody>
        </table>
    </div>
</div>
<p>A <code class="sh_cpp">vtable</code> természetesen a virtuális
metódustábla mutató, minden osztály példányaiban az osztály (nem az
objektum: az pazarlás lenne) saját táblájára mutat.</p>
<p>A többszörös öröklés tényleges megvalósítása fordítófüggő, ezért
nem részletezzük. A lényeg, hogy a <code class="sh_cpp">TeamLeader</code> és a
<code class="sh_cpp">TeamMember</code> egyenként már tartalmazza a <code
class="sh_cpp">Member</code> mezőit, és ezzel a bővítési mechanizmussal
nincs esély arra, hogy a <code class="sh_cpp">MiddleTeamLeader</code>
szülőosztálybeli függvényei megfelelő objektumot lássanak, miközben nincs
két <code class="sh_cpp">Member</code> szülő beágyazva.</p>
<p>A megoldás a virtuális szülőosztály. A segítségével a <code
class="sh_cpp">TeamLeader</code> és a <code class="sh_cpp">TeamMember</code>
&bdquo;részei&rdquo; a <code class="sh_cpp">MiddleTeamLeader</code>
osztálynak közös <code class="sh_cpp">Member</code>t látnak.</p>
<pre class="sh_cpp" data-source="extend/virtualInheritance.h"></pre>
<pre class="sh_cpp" data-source="extend/virtualInheritance.cc"></pre>
<pre class="console" data-source="extend/virtualInheritance.txt"></pre>
<h2>Adatmodellezési elvek</h2>
<p>Ha a gyakorlatban virtuális ősosztályokat kell használnod, esélyes, hogy
valamit nagyon rosszul modelleztél le.</p>
<p>A gyakorlatban fontos érteni a különbséget az <em>&bdquo;X egy Y&rdquo;</em>
és az <em>&bdquo;X része Y&rdquo;</em> kijelentés között, mert nem lesz
mindig egyértelmű. Az első öröklést (a téglalap egy síkidom, van pl. területe),
a második objektum kompozíciót jelent (pl. a téglalap egy pontból és egy
méretből áll, a téglalap viszont nem pont és nem méret).</p>
</section>
<section id="conversion">
<h1>Típuskonverziók</h1>
<h2>Konverziók megvalósítása</h2>
<p>Mindenről volt már szó, összefoglalva:</p>
<pre class="sh_cpp" data-source="conversion/conversion.cc"></pre>
<pre class="console" data-source="conversion/conversion.txt"></pre>
<h2>Típuskonverziós operátorok</h2>
<p>Nézzük a klasszikus C-ben megismert típuskonverziót:</p>
<pre class="sh_cpp" data-source="conversion/miscasting.cc"></pre>
<p>Egy szó nélkül lefordítja:</p>
<pre class="console" data-source="conversion/miscasting.txt"></pre>
<p>Ez nem probléma, ha tudja az ember, hogy mit csinál, de jó lenne, ha
meg tudnánk tenni ezt úgy is, hogy figyelmeztessen a rendszer:</p>
<pre class="sh_cpp" data-source="conversion/castingerror.cc"></pre>
<pre class="console" data-source="conversion/castingerror.txt"></pre>
<p>Nem engedi, mert ez két teljesen különböző osztály.</p>
<pre class="sh_cpp" data-source="conversion/staticcast.cc"></pre>
<pre class="console" data-source="conversion/staticcast.txt"></pre>
<p>Sajnos a <code class="sh_cpp">static_cast</code> engedi a bővítést
is, cserébe viszont gyors, és nem dobja meg a program méretét:</p>
<pre class="sh_cpp" data-source="conversion/downcast.cc"></pre>
<pre class="console" data-source="conversion/downcast.txt"></pre>
<p>A megoldás erre az esetre a <code class="sh_cpp">dynamic_cast</code>
lenne, amelyhez be kell kapcsolni a fordítóban a futási idejű
típusinformációt (RTTI, run-time type information). A példám sajnos nem úgy
fut le, mint amit vártam: elvileg null pointert kellene visszaadnia, vagy
kivételt dobnia (erről később), ehhez képest egyik sem történik meg:
&bdquo;Segmentation fault&rdquo; üzenetet kapok.</p>
<pre class="sh_cpp" data-source="conversion/dynamiccast.cc"></pre>
<p>A <code class="sh_cpp">dynamic_cast</code> használata kerülendő, mert
lassú, és megdobja a program méretét.</p>
<p>A <code class="sh_cpp">const_cast</code> segítségével a <code
class="sh_cpp">const</code> kulcsszótól szabadulhatunk meg. Használjuk
módjával, csak nagyon indokolt esetben.</p>
<pre class="sh_cpp" data-source="conversion/constcast.cc"></pre>
<p>Megmaradt a <code class="sh_cpp">reinterpret_cast</code>, ami bármilyen
mutatót bármilyen mutatóra vált kérdés és megfontolás nélkül, valamint akár
<code class="sh_cpp">int</code> típusú értéket is hajlandó mutatóként
értelmezni (ha elég széles a platformon: 64 bites fordítás esetén már nem
<code class="sh_cpp">int</code>, hanem <code class="sh_cpp">long long</code>
szélességű a mutató).</p>
<pre class="sh_cpp" data-source="conversion/reinterpretcast.cc"></pre>
<pre class="console" data-source="conversion/reinterpretcast.txt"></pre>
</section>
<section id="trycatch">
<h1>Kivételkezelés</h1>
<p>A hibakezelésre C-ben nincs igazán jó megoldás. Feláldozhatjuk a
függvények visszatérési értékét, és visszatérhetnek hibakóddal, de nagyon
megbonyolítja a kódot:</p>
<pre class="sh_cpp">int calculate(Value **result)
{
    // f1, f2, f3 valamit kiszamol, ami el is szallhat
    // 0-val valo visszateres a siker
    // ossze akarjuk vonni oket
    *result = new Value();
    Value *merged = *result;
    Value value;
    int error;
    error = f1(&amp;value);
    if(error)
    {
        delete *result;
        *result = 0;
        return error;
    }
    
    merged->merge(value);
    
    error = f2(&amp;value);
    if(error)
    {
        delete *result;
        *result = 0;
        return error;
    }
    
    merged->merge(value);
    
    error = f3(&amp;value);
    if(error)
    {
        delete *result;
        *result = 0;
        return error;
    }
    
    merged->merge(value);
    
    return 0;
}</pre>
<p>Erre alkották meg a kivételkezelést. Először maradjunk meg csak a
hibakódoknál, de most már ne áldozzuk fel a visszatérési értéket.</p>
<pre class="sh_cpp">Value* calculate()
{
    Value *result = new Value();
    
    try
    {
        result->merge(f1());
        result->merge(f2());
        result->merge(f3());
    }
    catch(int error)
    {
        delete result;
        throw error;
    }
    
    return result;
}</pre>
<p>Sokkal letisztultabb, átláthatóbb és egyszerűbb. A <code
class="sh_cpp">throw</code> segítségével dobhatunk valamilyen értéket, amit
a <code class="sh_cpp">try</code> <code class="sh_cpp">catch</code> ágával
kaphatunk el. Nem kell feláldoznunk a függvény visszatérési értékét sem.</p>
<p>Dobni bármilyen típust lehet, minden típusra írhatunk külön <code
class="sh_cpp">catch</code> ágat. Az ágak közül mindig a legelső for
lefutni, ami illeszkedik az adott értékre, vagyis ha el szeretnénk kapni
szülő- és gyermekosztályhoz is tartozó példányt, akkor az utóbbit kell előre
írni, egyébként a szülőosztály példányát elkapó ág fog lefutni mindig.</p>
<p>Kérdés még, hogy el lehet-e kapni azt, amiről nem tudjuk, hogy micsoda,
vagyis &bdquo;minden mást.&rdquo;</p>
<pre class="sh_cpp" data-source="trycatch/catchall.cc"></pre>
<pre class="console" data-source="trycatch/catchall.txt"></pre>
<h2>A dobott típusok megjelölése</h2>
<p>A függvény szignatúrában megjelölhetjük, hogy milyen típusú értékeket
dobhat a függvény. Ez nem jelenti azt, hogy a belső, jelöletlen függvények
nem dobhatnak mást, vagy nagyon csúnya vége lesz:</p>
<pre class="sh_cpp" data-source="trycatch/funthrow.cc"></pre>
<pre class="console" data-source="trycatch/funthrow.txt"></pre>
<p>A helyzet akkor is ugyanez, ha nem közvetlenül az <code
class="sh_cpp">f()</code> függvény dobja a kivételt, hanem valamelyik másik,
amelyik nem is deklarálta a dobott típusokat.</p>
<p>Persze tekinthetjük égbekiáltó hibának, ha olyan kivételt dobnak, amire
nem vagyunk egyáltalán felkészülve. Ez néhány esettől eltekintve követendő
gyakorlatnak is tekinthető. Ha mégis szeretnénk kultúráltan, egy <code
class="sh_cpp">catch</code> ágban kezelni, akkor használhatunk egy egyéni
<code class="sh_cpp">unexpected</code> függvényt és a szabvány
C++ könyvtár <code class="sh_cpp">std::bad_exception</code> osztályát:</p>
<pre class="sh_cpp" data-source="trycatch/badthrow.cc"></pre>
<pre class="console" data-source="trycatch/badthrow.txt"></pre>
<h2>A szabvány C++ könyvtár kivétel osztályai</h2>
<p>A szabvány C++ könyvtár deklarál pár kivétel osztályt. Nézzük ezeket
header szerint.</p>
<h3>&lt;exception&gt;</h3>
<dl>
<dt>exception</dt>
<dd><p>A szabvány C++ kivételek ősosztálya. Természetesen ebből származtatva
saját kivétel osztályokat is létrehozhatunk. Ha ilyet kapunk el, az alábbi
függvényt használhatjuk, vagy ha saját osztályt hozunk létre,
akkor az alábbi függvényt érdemes felülcsapni:</p>
<pre class="sh_cpp">virtual const char* what() const throw()</pre>
<p>Amíg ezen a szinten kapjuk el a kivételeket, ez a legtöbb, amit
kiszedhetünk belőle: egy stringet. Természetesen ha saját osztályt
készítünk, akkor további paraméterek átadására is lehetőség van.</p>
<p>Ha saját osztályt készítünk a <code class="sh_cpp">what()</code> függvény
felülcsapásán kívül érdemes copy konstruktort (ha a sima másolás nem felel
meg) és esetleg <code class="sh_cpp">operator=</code> függvényt írnunk.</p></dd>
<dt>bad_exception</dt>
<dd>Ezt már ismerjük.</dd>
</dl>
<h3>&lt;new&gt;</h3>
<dl>
<dt>bad_alloc</dt>
<dd>A <code class="sh_cpp">new</code> operátor dobja, ha nem sikerül az
allokációt végrehajtania.</dd>
</dl>
<h3>&lt;stdexcept&gt;</h3>
<dl>
<dt>runtime_error</dt>
<dd>Csak futás közben észrevehető hibák esetén dobja, pl. mert nem megfelelő értékek jöttek
ki (pl. nullával való osztás).
A gyermekosztályai:
<code class="sh_cpp">range_error</code>,
<code class="sh_cpp">overflow_error</code>,
<code class="sh_cpp">underflow_error</code>.
</dd>
<dt>logic_error</dt>
<dd>A program logikában történő hibák esetén dobja.
A gyermekosztályai:
<code class="sh_cpp">invalid_argument</code>,
<code class="sh_cpp">out_of_range</code>,
<code class="sh_cpp">length_error</code>,
<code class="sh_cpp">domain_error</code>.
</dd>
</dl>
</section>
<section id="templates">
<h1>Sablonok</h1>
</section>
</article>
<script type="application/javascript" src="js/sh_cpp.js"></script>
<script type="application/javascript" src="js/sh_main.js"></script>
<script type="application/javascript" src="http://ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
<script type="application/javascript" src="js/highlightDocument.js"></script>
</body>
</html>
