<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8"/>
<title>C++ jegyzet</title>
<link rel="stylesheet" href="css/sh_style.css"/>
<link rel="stylesheet" href="css/notes.css"/>
<meta name="viewport" content="width=device-width, user-scalable=no"/>
</head>
<body>
<ol>
<li><a href="#compiling">Fordítás</a></li>
<li><a href="#newLanguageElements">Új nyelvi elemek</a></li>
<li><a href="#oo">Objektum-orientált fejlesztés</a></li>
<li><a href="#oocc">Osztályok C++-ban</a></li>
<li><a href="#staticAndNamespaces">Statikus deklarációk és névterek</a></li>
<li><a href="#ccio">C++ I/O</a></li>
<li><a href="#opover">Operátor túlterhelés</a></li>
</ol>
<article>
<section id="compiling">
<h1>Fordítás</h1>
<p>A futtatható állomány előállítása három lépésből áll: preprocesszálás
&rarr; fordítás &rarr; összeállítás (preprocessor &rarr; compiler &rarr;
linker).</p>
<h2>Preprocesszálás</h2>
<p>A preprocesszálás végeredménye ritkán jelenik meg külön állományként, a
fordítás részeként fut le.</p>
<pre class="sh_cpp" data-source="preproctest/preproctest.cc"></pre>
<pre class="sh_cpp" data-source="preproctest/some_header.h"></pre>
<p>Ha azt akarjuk, hogy a fordító csak preprocesszáljon, akkor a
<code>-E</code>
kapcsolót kell használnunk gcc vagy clang esetén. Ekkor a stdoutra kiírja
azt, ami egyébként a fordítónak ment volna. Ha a kimenetet megnézzük, az
include egyszerűen csak beilleszti a megadott állományt a forrásba, ezen
kívül belekerül pár különös jel, ezekkel tud a fordító a hibakijelzésnél
az eredeti források soraira hivatkozni.</p>
<pre class="console" data-source="preproctest/output.txt"></pre>
<h2>Fordítás</h2>
<p>A fordítás során minden egyes <code>.cc</code>/<code>.cpp</code>
forrásból objektum állomány (<code>.o</code>/<code>.obj</code>) készül.
Az objektum állomány tartalmazza, a változók neveit, a függvények neveit
és gépi kódú forrását, valamint hogy ezek a függvények hol hivatkoznak meg
változókat és más függvényeket. Itt még nincs eldöntve, hogy a memóriában
hol fognak az egyes függvény kódok és globális változók elhelyezkedni.</p>
<p>A külső nevek típusának az ellenőrzése a fordító feladata, de ahhoz, hogy
ezt megtehesse, tudnia kell róla.</p>
<pre class="sh_cpp" data-source="refer1/refer1.cc"></pre>
<pre class="sh_cpp" data-source="refer1/util.cc"></pre>
<p>Ha azt akarjuk, hogy csak a preprocesszáló és a fordító fusson le,
használjuk a <code>-c</code> kapcsolót.</p>
<pre class="console" data-source="refer1/output.txt"></pre>
<p>A máshol definiált függvényeket és globális változókat deklarálni minden
egyes forrásban, ahol használni akarjuk komoly hibaforrás és rengeteg
pluszmunka, ezért szokás egy <code>.h</code> forrásba beletenni mindazon
változókat és függvényeket, amit egy másik modul számára elérhetővé akarunk
tenni. Ezt teszi minden egyes rendszerkönyvtár.</p>
<pre class="sh_cpp" data-source="refer2/refer2.cc"></pre>
<pre class="sh_cpp" data-source="refer2/util.h"></pre>
<pre class="sh_cpp" data-source="refer2/util.cc"></pre>
<pre class="console" data-source="refer2/output.txt"></pre>
<p>Előfordulhat, hogy a <code>util.h</code>-ban definiált
<code>Record</code> típust használja több modul is, pl. a függvények
paraméterlistájában. Elkerülhetetlen, hogy emiatt közvetve többször is
befűződjön a <code>util.h</code>. A típust újradeklarálni viszont nem
lehet.</p>
<pre class="sh_cpp" data-source="refer2/include.cc"></pre>
<pre class="console" data-source="refer2/include.txt"></pre>
<p>Ezért szokás a fejléceket makrókkal körülbástyázni, hogy ha újra
megjelennének egy fordítási egységben, akkor lényegében nem tartalmaznak
semmit.</p>
<pre class="sh_cpp" data-source="refer2/util_safe.h"></pre>
<p>A gyakorlatban minden népszerű fordító támogatja a nem szabványos
<code class="inline sh_cpp">#pragma once</code> direktívát, amivel ugyanezt
lehet <a href="http://en.wikipedia.org/wiki/Pragma_once">egyetlen plusz sorral
megvalósítani</a>. A vizsgán ne használd.</p>
<p>Minden olyan függvényt, amit nem használunk modulon kívüli használatra
érdemes úgy deklarálnunk, hogy azt más modulok még véletlenül se érhessék
el, hogy egy nagyobb program esetén ne érjenek kellemetlen meglepetések.
C-ben ezt a <code class="sh_cpp">static</code> kulcsszó használatával lehet elérni, C++-ban lehetőség
van <code class="sh_cpp">static</code> kulcsszót használni vagy névtelen névteret létrehozni (a
névterekről később).</p>
<pre class="sh_cpp" data-source="refer3/util.cc"></pre>
<pre class="sh_cpp" data-source="refer3/refer3.cc"></pre>
<pre class="console" data-source="refer3/output.txt"></pre>
<p>A példában a <code>foo</code> változót megtalálta, de a <code>bar</code>t
nem.</p>
<h2>Összeállítás</h2>
<p>A linker feladata, hogy eldöntse, hogy futás során hol fognak
elhelyezkedni a memóriában a globális változók és a függvények gépi kódja,
és hogy ez utóbbiak a már megállapított címen keressék őket.</p>
<p>Nagyon fontos tudni, hogy a linkerben a C++ már díszített (decorated)
neveket használ, ellentétben a C-vel, mert C++-ban már nem elég pusztán a
függvény nevét tudni a beazonosításhoz.</p>
<pre class="sh_cpp" data-source="link1/util.c"></pre>
<pre class="sh_cpp" data-source="link1/link1.cc"></pre>
<pre class="console" data-source="link1/output.txt"></pre>
<p>A C++ kód nem látta azt a C függvényt, amelyiket nem <code
class="sh_cpp">extern "C"</code> kulcsszóval deklaráltunk, illetve a C kód
nem látta azt a C++ függvényt, amit nem ezzel a kulcsszóval definiáltunk.</p>
<p>Az <code class="sh_cpp">extern "C"</code> lényegében azt mondja: &bdquo;erre a
deklarációra vagy definícióra ne használj díszített neveket!&rdquo; Van
<code class="sh_cpp">extern "C" { /* ... */ }</code> formája is, amivel
egyszerre több deklarációra vagy definícióra lehet ezt a módot beállítani.
Elsősorban C rutinkönyvtárak fejléceiben találkozni vele:</p>
<pre class="sh_cpp">#ifdef __cplusplus
extern "C" {
#endif

/* ... */

#ifdef __cplusplus
}
#endif</pre>
</section>
<section id="newLanguageElements">
<h1>Új nyelvi elemek</h1>
<h2>A <code class="sh_cpp">const</code> kulcsszó</h2>
<p>Előnyei:</p>
<ul>
<li>Ha átadok egy mutatót egy függvénynek, biztos lehetek, hogy nem fog a
tartalma változni, és a fordítót is biztosítom erről: ennek megfelelően
optimizálhatja a kódot</li>
<li>Elegánsabban lehet vele konstanst definiálni, mint a <code
class="sh_cpp">#define</code> direktívával: a konstansnak lesz típusa, és
lehet címe (a prefix &amp; operátorral)</li>
</ul>
<pre class="sh_cpp" data-source="new/const.cc"></pre>
<pre class="console" data-source="new/const.txt"></pre>
<h2>Egyszerűbb függvény deklaráció</h2>
<p>C-ben a <code class="sh_cpp">int main()</code> <code class="sh_cpp">int
main(...)</code>-nak felelt meg, a paraméter nélküli függvényeket <code
class="sh_cpp">int main(void)</code>-ként kellett deklarálni. C++-ban ez már
nem érvényes, a <code class="sh_cpp">int main()</code> ekvivalens a <code
class="sh_cpp">int main(void)</code> deklarációval.</p>
<h2>Változó deklaráció bárhol</h2>
<p>Bárhol lehet változót deklarálni, nem csak a blokkok elején és a
for ciklusokban.</p>
<pre class="sh_cpp" data-source="new/decl.cc"></pre>
<h2>Függvények túlterhelése</h2>
<p>A függvényeket már nem csak a nevük, hanem a paraméterlistájuk is
azonosítja, amíg egyértelmű.</p>
<pre class="sh_cpp" data-source="new/overload.cc"></pre>
<pre class="console" data-source="new/overload.txt"></pre>
<p>Többek között emiatt van szükség az <code class="sh_cpp">extern "C"</code>
módosítóra.</p>
<h2>Függvény paraméter alapértelmezett értékek</h2>
<p>A függvény utolsó paramétereinek adhatunk alapértelmezett értéket, ezzel
azok a paraméterek elhagyhatóvá válnak. Paramétereket elhagyni csak a
függvény végéről lehet, nem lehet pl. a harmadikat elhagyni, a negyediket
viszont megadni.</p>
<pre class="sh_cpp" data-source="new/default.cc"></pre>
<pre class="console" data-source="new/default.txt"></pre>
<h2>Referenciák</h2>
<p>Mutatók mellett referenciákat is használhatunk. A háttérben ezek is
mutatók, de nem tudjuk a mutató értékét megváltoztatni, csak azt az értéket,
amire mutat.</p><p>Ha a referenciát const kulcsszóval deklaráljuk, a fordító
képes automatikusan ideiglenes változót létrehozni, ha kell (lásd a példát).
Ha azonban a visszatérési érték referencia, akkor a biztonságos működéshez
csak olyan referenciát adhatunk vissza, ami nincs a függvény élettartamához
kötve. Ha mégis megtesszük, a program még le is fordulhat, de nem várt
eredményeket produkálhat.</p>
<pre class="sh_cpp" data-source="new/ref.cc"></pre>
<pre class="console" data-source="new/ref.txt"></pre>
<h2><code class="sh_cpp">inline</code> függvények</h2>
<p>A <code class="sh_cpp">#define</code> direktívával létrehozott
makró-függvényeknek kellemetlen mellékhatásai lehetnek:</p>
<pre class="sh_cpp">#define MUL(a, b) a*b
// ...
#define SIX 1+5
#define NINE 8+1
int val = MUL(SIX, NINE);
// val erteke 42 (nem 54)</pre>
<p>Zárójelezéssel javíthatunk rajta, a deklaráció nem lett szebb, és még így
is problémáink akadhatnak:</p>
<pre class="sh_cpp">#define MAX(a, b) ((a)>(b)?(a):(b))
// ...
int a = 6;
int b = 5;
int val = MAX(++a, b);
// a es val erteke mar 8</pre>
<p>Ezen kívül ha makrókat használunk, nincsenek típusdeklarációk,
nem lehet használni a túlterhelést, az alapértelmezett értékeket,
és egyebeket, amikről eddig nem volt szó. De szeretnénk, ha nem
hajtana végre külön függvényhívást, ha a fordító is úgy gondolja,
hogy ez kézenfekvő.</p>
<pre class="sh_cpp">inline int max(int a, int b)
{
    return a > b ? a : b;
}
// ...
int a = 6;
int b = 5;
int val = max(++a, b);
// a es val erteke 7</pre>
<p>A fordító nem veszi figyelembe az <code class="sh_cpp">inline</code>
kulcsszót, ha</p>
<ul>
<li>a függvénynek címét vesszük, és azzal hívjuk meg (elvileg közvetlen
meghívásnál még mindig befűzheti a hívás helyett)</li>
<li>a függvény rekurzív</li>
<li>a függvény túl bonyolult vagy nagy</li>
<li>fordító hóbortból</li>
</ul>
<h2>Implicit <code class="sh_cpp">typedef</code> struktúrákra</h2>
<p>A struktúrákra nem kell ezentúl <code class="sh_cpp">struct
StrukturaNev</code> formában hivatkozni, simán <code
class="sh_cpp">StrukturaNev</code> is megteszi.</p>
<pre class="sh_cpp">struct Rect {
    int x, y;
    int width, height;
};

// OK
struct Rect rect1;

// C++-ban mar ez is OK
Rect rect2;</pre>
</section>
<section id="oo">
<h1>Objektum-orientált fejlesztés</h1>
<p>Az OOP lényege, hogy objektumokkal dolgozunk. Objektum lehet pl. egy
komplex szám, egy dinamikus tömb vagy egy gomb a képernyőn. Az objektumokon
műveleteket lehet végezni. Az objektumok négy fontos elvet követnek:</p>
<dl><dt>Egységbezárás (encapsulation)</dt><dd>Az objektum és a műveletei
olyan formában jelennek meg a nyelvben, hogy szintaktikailag egységet
alkotnak. Ez a gyakorlatban azt jelenti, hogy az osztályoknak (és a
struktúráknak) tagfüggvényei lehetnek, amik megvalósítják a műveleteket.</dd>
<dt>Adatrejtés (information hiding)</dt><dd>Az objektum belső állapota nem
érhető el közvetlenül. Pl. a dinamikus tömb hosszához nem férhet hozzá
mezőnhivatkozáson keresztül, csak művelettel kérheti le és állíthatja, így a
dinamikus tömb megvalósíthatja az automatikus újraallokálást.</dd>
<dt>Öröklés (inheritance)</dt><dd>Az objektumok osztálya van, az osztályok
pedig más osztályokat bővíthetnek (&bdquo;örökölhetnek&rdquo; &ndash; nem
szeretem ezt a szóhasználatot, helyette rendre a &bdquo;bővített&rdquo; szót
fogom használni). Pl. a <code class="sh_cpp">Bicycle</code> egy bicikli adatait tárolja el (pl.
kerékátmérő és sebességek száma). Viszont biciklitől függően lehet, hogy
további adatokat akarunk megadni, pl. városi kerékpár (<code
class="sh_cpp">CityBike</code>) esetén a kosár
űrtartalmát. Nem kell újra megírnunk azt a függvényt, ami a kerék
fordulatszámából (a kerékátmérő ismeretében) a bicikli sebességét
kiszámolja, hiszen az ugyanaz a városi kerékpárra, mint bármely más
kerékpárra. A leszármazott osztályok új mezőkkel és függvényekkel bővíthetik
az ősosztályt, valamint az arra megjelölt függvényeket akár le is
cserélhetik.</dd>
<dt>Behelyettesíthetőség</dt><dd>Az osztályok bővítései behelyettesíthetővé
válnak oda, ahol a bővített osztályba (&bdquo;szülőosztályba&rdquo;) tartozó
objektum szerepelhet. Pl. ha egy függvény <code
class="sh_cpp">Bicycle*</code> vagy <code class="sh_cpp">Bicycle&amp;</code>
típusú paramétert vár, ott rendre <code class="sh_cpp">CityBike*</code> és <code
class="sh_cpp">CityBike&amp;</code> típusú érték is megadható.</dd>
<dt>Típustámogatás (extra, csak C++-ra és egy pár más nyelvre igaz)</dt><dd>Az
osztályok ugyanúgy működhetnek, mint a beépített típusok. Vagyis a
<code>Complex</code> osztály ugyanúgy működhet, mint a <code
class="sh_cpp">float</code> vagy a <code>double</code>.</dd>
</dl>
</section>
<section id="oocc">
<h1>Osztályok C++-ban</h1>
<pre class="sh_cpp" data-source="oo/point.h"></pre>
<p>A <code class="sh_cpp">class</code> abban különbözik a <code
class="sh_cpp">struct</code>-tól, hogy az alapértelmezett láthatóság <code
class="sh_cpp">private</code>. Háromféle láthatósági szint létezik:</p>
<ul>
<li><code class="sh_cpp">private:</code> csak az osztály látja</li>
<li><code class="sh_cpp">protected:</code> a bővíett osztályok (gyermekosztályok) is látják</li>
<li><code class="sh_cpp">public:</code> mindenki látja</li>
</ul>
<pre class="sh_cpp" data-source="oo/point.cc"></pre>
<pre class="sh_cpp" data-source="oo/first.cc"></pre>
<pre class="console" data-source="oo/first.txt"></pre>
<p>Figyeljük meg, hogy a destruktorokat fordított sorrendben hívja meg,
amikor az objektum kikerül a scope-ból.</p>
<p>Nagyon fontos, hogy a konstruktorokat nem hívjuk meg sehol. A fordító nem
fog szólni miatta, de ettől helytelen gyakorlat. Inkább hozzunk létre egy
függvényt, amit a konstruktor és a konstruktort hívó függvény meghív.</p>
<p>A destruktort sem hívjuk meg kézzel.</p>
<p>A <code>Point</code> osztálynak nincs paraméter nélküli, azaz
alapértelmezett konstruktora. Ezért az alábbi nem fordul:</p>
<pre class="sh_cpp" data-source="oo/nodefault.cc"></pre>
<pre class="console" data-source="oo/nodefault.txt"></pre>
<h2>A <code class="sh_cpp">new</code> és a <code
class="sh_cpp">delete</code> kulcsszó</h2>
<p>A C++ a memóriaallokációt nyelvi szinten tartalmazza. Allokálni a <ocde
class="sh_cpp">new</code> operátorral lehet, felszabadítani a <code
class="sh_cpp">delete</code> illetve a <code class="sh_cpp">delete[]</code>
operátorral. Az utóbbit abban az esetben kell alkalmazni, ha tömböt
szeretnénk felszabadítani. A C-vel ellentétben a memóriaallokáció mindig
típusos:</p>
<pre class="sh_cpp" data-source="oo/new.cc"></pre>
<p>Fontos megjegyezni, hogy az így létrehozott objektumok destruktorait nem a
scope-ból való kikerülésükkor, hanem a <code class="sh_cpp">delete</code>/<code
class="sh_cpp">delete[]</code> meghívásakor hívja meg automatikusan.</p>
<p>A <code class="sh_cpp">malloc</code> hívással ellentétben ez meghívja a
konstruktort is, még akkor is, ha tömböt allokálunk:</p>
<pre class="sh_cpp" data-source="oo/counter.h"></pre>
<pre class="sh_cpp" data-source="oo/counter.cc"></pre>
<pre class="sh_cpp" data-source="oo/second.cc"></pre>
<p>Jól látható, hogy a tömböt visszafelé szabadítja fel:</p>
<pre class="console" data-source="oo/second.txt"></pre>
<h2>A másoló konstruktor</h2>
<p>A Point osztályunknak van egy rejtett konstruktora. A tagfüggvény
<em>szignatúrája</em> valahogy így néz ki:</p>
<pre class="sh_cpp">Point::Point(const Point &amp;point);</pre>
<p>Ezt a fordító automatikusan generálta: egyszerűen minden mezőt lemásol.</p>
<pre class="sh_cpp" data-source="oo/third.cc"></pre>
<p>A változódeklarációnál leírt <code class="sh_cpp">=</code> nem ugyanaz,
mint az <code class="sh_cpp">=</code> művelet.</p>
<p>A másoló konstruktort testre is szabhatjuk, és ez néha szükséges is. Az
alábbi <code class="sh_cpp">StringBuffer</code> osztály egy karaktertömböt
allokál. Ha nem bíráljuk felül a másoló konstruktort, akkor egy az egyben
átveszi a mutatót a másik objektumból, és amelyiknek a destruktorát
másodjára hívja meg, az már felszabadított területre próbálja meghívni a
<code class="sh_cpp">delete</code>-et.</p>
<pre class="sh_cpp" data-source="oo/stringbuffer.h"></pre>
<pre class="sh_cpp" data-source="oo/stringbuffer.cc"></pre>
<p>A <code class="sh_cpp">this</code> mindig az aktuális objektumra mutat.
Akkor használjuk, ha az aktuális objektumunkra kell egy mutató (meglepő
módon), vagy egy olyan mezőt akarunk elérni, aminek a nevét elfedi egy
lokális változó. Vagy azért, mert ilyen hülye szokásunk van.</p>
</section>
<section id="staticAndNamespaces">
<h1>Statikus deklarációk és névterek</h1>
<h2>A <code class="sh_cpp">static</code> kulcsszó függvényekben</h2>
<p>A <code class="sh_cpp">static</code> kulcsszó C-ben és C++-ban egyaránt
rendelkezésre áll függvényeken belül is:
</p>
<pre class="sh_cpp">void foo()
{
    static int count = 0;
    printf("%d\n", ++count);
}</pre>
<p>Az ilyen statikus változók inicializálója csak egyszer hívódik meg, és
hívásról hívásra megőrzi az értékét, pont mint egy globális változó. A
globális változóval ellentétben viszont nem érhető el, csak a függvényen
belülről.</p>
<h2>A <code class="sh_cpp">static</code> kulcsszó osztályokban</h2>
<p>Az osztályhoz kötött statikus mezők és függvények szintén globális
változóként működnek, azaz nem kötöttek objektum példányhoz, a láthatóságuk
pedig a <code class="sh_cpp">public</code>/<code class="sh_cpp">protected</code>/<code
class="sh_cpp">private</code> elérési sémákkal szabályozhatók.</p>
<pre class="sh_cpp" data-source="vis/stat.cc"></pre>
<pre class="console" data-source="vis/stat.txt"></pre>
<p>Figyeljük meg, hogy a statikus mező deklaráció egy <code
class="sh_cpp">extern</code> változódeklarációval egyenértékű, vagyis a változót
még külön egyszer deklarálni kell, ahol egyébként a kezdőérték is megadható.
Megosztott komponenseknél ezt az osztály implementációját tartalmazó forrásba célszerű
tenni.</p>
<h2>A <code class="sh_cpp">friend</code> kulcsszó</h2>
<p>A <code class="sh_cpp">friend</code> kulcsszóval hozzáférést adhatunk az
osztály <code class="sh_cpp">protected</code> és <code
class="sh_cpp">private</code> mezőihez más függvények és osztályok számára
(ez esetben az osztály valamennyi tagfüggvénye hozzáférhet a mezőkhöz).
A friend deklarációt az osztályon belül bárhova írhatjuk, minden esetben
ugyanazt jelenti.</p>
<pre class="sh_cpp" data-source="vis/friend.cc"></pre>
<h2>Névterek</h2>
<p>Más nyelvekben, ahol nincs lehetőség globális változókat vagy
függvényeket deklarálni, előfordul, hogy az összetartozó konstansokat,
függvényeket vagy globális változókat egy osztályban deklarálják statikus
elemekként. Ami szép, mert az összetartozó elemeket egybefogja, és csúnya,
mert mindezt osztályokkal teszi. C++-ban erre nincs szükség: használhatjuk a
<code class="sh_cpp">namespace</code> kulcsszót.</p>
<pre class="sh_cpp" data-source="vis/ns.cc"></pre>
<pre class="console" data-source="vis/ns.txt"></pre>
<p>Figyeljük meg, hogy a show függvényben (illetve bármely deklarációban a
névteren belül) a névtér saját változóit részesíti előnyben. A névtér
nélküli globális változókat elérni a négyesponttal tudja. A négyesponttal
kezdődő minősített neveknél a névtereket teljesen kézzel adjuk meg. Az
alábbi példa &ndash; bár nem szép &ndash; demonstrálja, hol lehet ez
szükséges:</p>
<pre class="sh_cpp" data-source="vis/badns.cc"></pre>
<pre class="console" data-source="vis/badns.txt"></pre>
<p>C++-ban minden standard C könyvtárnak megtalálható a C++ verziója, ami
annyiban különbözik, hogy a rendszerhívások belekerülnek a std névtérbe. A
header nevét a &bdquo;.h&rdquo; elhagyásával és a &bdquo;c&rdquo; előtag
hozzáadásával kapjuk meg.</p>
<p>Globális statikus változók és függvények (vagyis amik csak az adott
fordítási egységben láthatók) üres névtérrel is deklarálhatók:</p>
<pre class="sh_cpp">namespace
{
    // mas forditasi egysegbol nem lathato,
    // pont mint a static kulcsszoval
    int lokalis = 1;
}</pre>
<p>Névterekben található változók és függvények semmilyen formában nem
oszthatóak meg C modulokkal.</p>
<h2>A <code class="sh_cpp">using</code> kulcsszó</h2>
<p>A <code class="sh_cpp">using</code> kulcsszó használatával
egyszerűsíthetjük a névterekben lévő elemek elérését. A deklaráció mindig a
fordítási egységre vonatkozik, vagyis header esetén minden C++ forrásra
érvényes lesz, amelyik a headert befűzi, ezért headerbe ilyet írni nem szép
dolog. A <code class="sh_cpp">using</code> önmagában egyetlen nevet tesz
elérhetővé a névtér megadása nélkül. A <code class="sh_cpp">using
namespace</code> a névtér valamennyi elemét elérhetővé teszi a
névtérmegjelölés (kvalifikáció) nélkül.</p>
<pre class="sh_cpp" data-source="oo/using.cc"></pre>
</section>
<section id="ccio">
<h1>C++ I/O</h1>
<h2>Folyamok (streamek)</h2>
<p>Ahogyan a C-s szöveges I/O legtöbbet használt része a formátum stirng,
úgy a C++ I/O alapja a stream. A <code class="sh_cpp">stdout</code> C++-ban a <code
class="sh_cpp">std::cout</code>, a <code class="sh_cpp">stderr</code> pedig a
<code class="sh_cpp">std::cerr</code>.</p>
<p>Az elmaradhatatlan &bdquo;Hello World!&rdquo; alkalmazás:</p>
<pre class="sh_cpp" data-source="io/hello.cc"></pre>
<p>A <code class="sh_cpp">std::endl</code> azon kívül, hogy kiír egy
soremelés karaktert, üríti a buffert is: a karaktereket ugyanis a rendszer nem
egyenként szokta a rendszer a képernyőre írni, hanem kötegelve (ez C-ben sem
volt másképp, legfeljebb nem tudtatok róla :D).</p>
<p>A <code class="sh_cpp">std::cout</code>-hoz hasonlóan van <code
class="sh_cpp">std::cin</code> is:</p>
<pre class="sh_cpp" data-source="io/circumference.cc"></pre>
<p>A program beolvassa a radius változóba a <code>stdin</code>ről egy tört
értéket, majd kiszámolja a kör kerületét és kiírja.</p>
<p>Figyeljük meg, hogy a shift operátor nyilai a kimenetnél a kimenet felé
mutatnak, a bemenetnél pedig onnan indulnak ki (hogy miért tud a shift
operátor ilyen különösen viselkedni, arról később lesz szó).</p>
<h2>Írás állományokba</h2>
<p>Az <code class="sh_cpp">ifstream</code> és az <code
class="sh_cpp">ofstream</code> osztályokkal történik. Szöveges formázott elérés:</p>
<pre class="sh_cpp" data-source="io/distance.cc"></pre>
<pre class="console" data-source="io/coords.txt"></pre>
<pre class="console" data-source="io/distances.txt"></pre>
<p>Egyéb elérési módok (itt most ifstream és ofstream helyett a
szülőosztályt, az istreamet és az ostreamet használom):</p>
<pre class="sh_cpp" data-source="io/string.cc"></pre>
<pre class="console" data-source="io/string.txt"></pre>
<h2>Mezők formázása</h2>
<pre class="sh_cpp" data-source="io/format.cc"></pre>
<pre class="console" data-source="io/format.txt"></pre>
</section>
<section id="opover">
<h1>Operátor túlterhelés</h1>
<p>Operátorokat definiálhatunk olyan típusokra, amikre egyébként nincsenek.
Nem változtathatjuk meg az eredeti működést (vagy legalábbis nagyon nem
javaslom), nem változtathatjuk meg a
precedenciát, nem hozhatunk létre teljesen új operátorokat (pl. <code
class="sh_cpp">**</code>)</p>
<p>Az operátorok legalább egyik tagja osztály kell, hogy legyen.</p>
<pre class="sh_cpp" data-source="opover/complex.cc"></pre>
<pre class="console" data-source="opover/complex.txt"></pre>
<p>Figyeljük meg, milyen sorrendben értékeli ki őket:</p>
<pre class="sh_cpp" data-source="opover/order.cc"></pre> 
<pre class="console" data-source="opover/order.txt"></pre> 
<p>Kérdés még, hogy hogyan különböztetjük meg a prefix és a
posztfix <code class="sh_cpp">++</code> operátort.</p>
<pre class="sh_cpp">class A
{
    int val;
public:
    //
    // ...
    //
    
    // ++a
    A&amp; operator++()
    {
        ++val;
        return *this;
    }
    
    // a++
    A operator++(int)
    {
        // elmentjuk az eredeti erteket
        A result(*this);
        ++val;
        return result;
    }
    
    //
    // ...
    //
};</pre>
<p>A posztfix <code class="sh_cpp">++</code> és <code
class="sh_cpp">--</code> operátorhoz meg kell követelnünk egy extra <code
class="sh_cpp">int</code> paramétert, amit nem használunk fel.</p>
<h2>Típuskonverzió, mint operátor</h2>
<pre class="sh_cpp" data-source="opover/simplecomplex.cc"></pre>
<pre class="console" data-source="opover/simplecomplex.txt"></pre>
<p>Figyeljük meg, hogy a típuskonverziós operátoroknál hiányzik a
visszatérési érték típusa, mert azt az <code class="sh_cpp">operator</code>
kulcsszó után adjuk meg.</p>
<p>A függvényhívás operátor az egyetlen, amely tetszőleges számú paramétert
vehet fel. A példában nem ez szerepel, de deklarálhattam volna <code
class="sh_cpp">double operator()()</code> szignatúrával is tagfüggvényként,
vagy <code class="sh_cpp">double operator()(Poly3 &amp;p)</code> kívülről.</p>
<pre class="sh_cpp" data-source="opover/poly3.cc"></pre>
<pre class="console" data-source="opover/poly3.txt"></pre>
</section>
</article>
<script type="application/javascript" src="js/sh_cpp.js"></script>
<script type="application/javascript" src="js/sh_main.js"></script>
<script type="application/javascript" src="http://ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
<script type="application/javascript" src="js/highlightDocument.js"></script>
</body>
</html>
