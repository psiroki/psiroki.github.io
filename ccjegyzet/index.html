<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8"/>
<title>C++ jegyzet</title>
<link rel="stylesheet" href="css/sh_style.css"/>
<link rel="stylesheet" href="css/notes.css"/>
<meta name="viewport" content="width=device-width, user-scalable=no"/>
</head>
<body>
<ol>
<li><a href="#compiling">Fordítás</a></li>
<li><a href="#newLanguageElements">Új nyelvi elemek</a></li>
</ol>
<article>
<section id="compiling">
<h1>Fordítás</h1>
<p>A futtatható állomány előállítása három lépésből áll: preprocesszálás
&rarr; fordítás &rarr; összeállítás (preprocessor &rarr; compiler &rarr;
linker).</p>
<h2>Preprocesszálás</h2>
<p>A preprocesszálás végeredménye ritkán jelenik meg külön állományként, a
fordítás részeként fut le.</p>
<pre class="sh_cpp" data-source="preproctest/preproctest.cc"></pre>
<pre class="sh_cpp" data-source="preproctest/some_header.h"></pre>
<p>Ha azt akarjuk, hogy a fordító csak preprocesszáljon, akkor a
<code>-E</code>
kapcsolót kell használnunk gcc vagy clang esetén. Ekkor a stdoutra kiírja
azt, ami egyébként a fordítónak ment volna. Ha a kimenetet megnézzük, az
include egyszerűen csak beilleszti a megadott állományt a forrásba, ezen
kívül belekerül pár különös jel, ezekkel tud a fordító a hibakijelzésnél
az eredeti források soraira hivatkozni.</p>
<pre class="console" data-source="preproctest/output.txt"></pre>
<h2>Fordítás</h2>
<p>A fordítás során minden egyes <code>.cc</code>/<code>.cpp</code>
forrásból objektum állomány (<code>.o</code>/<code>.obj</code>) készül.
Az objektum állomány tartalmazza, a változók neveit, a függvények neveit
és gépi kódú forrását, valamint hogy ezek a függvények hol hivatkoznak meg
változókat és más függvényeket. Itt még nincs eldöntve, hogy a memóriában
hol fognak az egyes függvény kódok és globális változók elhelyezkedni.</p>
<p>A külső nevek típusának az ellenőrzése a fordító feladata, de ahhoz, hogy
ezt megtehesse, tudnia kell róla.</p>
<pre class="sh_cpp" data-source="refer1/refer1.cc"></pre>
<pre class="sh_cpp" data-source="refer1/util.cc"></pre>
<p>Ha azt akarjuk, hogy csak a preprocesszáló és a fordító fusson le,
használjuk a <code>-c</code> kapcsolót.</p>
<pre class="console" data-source="refer1/output.txt"></pre>
<p>A máshol definiált függvényeket és globális változókat deklarálni minden
egyes forrásban, ahol használni akarjuk komoly hibaforrás és rengeteg
pluszmunka, ezért szokás egy <code>.h</code> forrásba beletenni mindazon
változókat és függvényeket, amit egy másik modul számára elérhetővé akarunk
tenni. Ezt teszi minden egyes rendszerkönyvtár.</p>
<pre class="sh_cpp" data-source="refer2/refer2.cc"></pre>
<pre class="sh_cpp" data-source="refer2/util.h"></pre>
<pre class="sh_cpp" data-source="refer2/util.cc"></pre>
<pre class="console" data-source="refer2/output.txt"></pre>
<p>Előfordulhat, hogy a <code>util.h</code>-ban definiált
<code>Record</code> típust használja több modul is, pl. a függvények
paraméterlistájában. Elkerülhetetlen, hogy emiatt közvetve többször is
befűződjön a <code>util.h</code>. A típust újradeklarálni viszont nem
lehet.</p>
<pre class="sh_cpp" data-source="refer2/include.cc"></pre>
<pre class="console" data-source="refer2/include.txt"></pre>
<p>Ezért szokás a fejléceket makrókkal körülbástyázni, hogy ha újra
megjelennének egy fordítási egységben, akkor lényegében nem tartalmaznak
semmit.</p>
<pre class="sh_cpp" data-source="refer2/util_safe.h"></pre>
<p>A gyakorlatban minden népszerű fordító támogatja a nem szabványos
<code class="inline sh_cpp">#pragma once</code> direktívát, amivel ugyanezt
lehet <a href="http://en.wikipedia.org/wiki/Pragma_once">egyetlen plusz sorral
megvalósítani</a>. A vizsgán ne használd.</p>
<p>Minden olyan függvényt, amit nem használunk modulon kívüli használatra
érdemes úgy deklarálnunk, hogy azt más modulok még véletlenül se érhessék
el, hogy egy nagyobb program esetén ne érjenek kellemetlen meglepetések.
C-ben ezt a static kulcsszó használatával lehet elérni, C++-ban lehetőség
van static kulcsszót használni vagy névtelen névteret létrehozni (a
névterekről később).</p>
<pre class="sh_cpp" data-source="refer3/util.cc"></pre>
<pre class="sh_cpp" data-source="refer3/refer3.cc"></pre>
<pre class="console" data-source="refer3/output.txt"></pre>
<p>A példában a <code>foo</code> változót megtalálta, de a <code>bar</code>t
nem.</p>
<h2>Összeállítás</h2>
<p>A linker feladata, hogy eldöntse, hogy futás során hol fognak
elhelyezkedni a memóriában a globális változók és a függvények gépi kódja,
és hogy ez utóbbiak a már megállapított címen keressék őket.</p>
<p>Nagyon fontos tudni, hogy a linkerben a C++ már díszített (decorated)
neveket használ, ellentétben a C-vel, mert C++-ban már nem elég pusztán a
függvény nevét tudni a beazonosításhoz.</p>
<pre class="sh_cpp" data-source="link1/util.c"></pre>
<pre class="sh_cpp" data-source="link1/link1.cc"></pre>
<pre class="console" data-source="link1/output.txt"></pre>
<p>A C++ kód nem látta azt a C függvényt, amelyiket nem <code
class="sh_cpp">extern "C"</code> kulcsszóval deklaráltunk, illetve a C kód
nem látta azt a C++ függvényt, amit nem ezzel a kulcsszóval definiáltunk.</p>
<p>Az <code class="sh_cpp">extern "C"</code> lényegében azt mondja: &bdquo;erre a
deklarációra vagy definícióra ne használj díszített neveket!&rdquo; Van
<code class="sh_cpp">extern "C" { /* ... */ }</code> formája is, amivel
egyszerre több deklarációra vagy definícióra lehet ezt a módot beállítani.
Elsősorban C rutinkönyvtárak fejléceiben találkozni vele:</p>
<pre class="sh_cpp">#ifdef __cplusplus
extern "C" {
#endif

/* ... */

#ifdef __cplusplus
}
#endif</pre>
</section>
<section id="newLanguageElements">
<h1>Új nyelvi elemek</h1>
<h2>A <code class="sh_cpp">const</code> kulcsszó</h2>
<p>Előnyei:</p>
<ul>
<li>Ha átadok egy mutatót egy függvénynek, biztos lehetek, hogy nem fog a
tartalma változni, és a fordítót is biztosítom erről: ennek megfelelően
optimizálhatja a kódot</li>
<li>Elegánsabban lehet vele konstanst definiálni, mint a <code
class="sh_cpp">#define</code> direktívával: a konstansnak lesz típusa, és
lehet címe (a prefix &amp; operátorral)</li>
</ul>
<pre class="sh_cpp" data-source="new/const.cc"></pre>
<pre class="console" data-source="new/const.txt"></pre>
<h2>Egyszerűbb függvény deklaráció</h2>
<p>C-ben a <code class="sh_cpp">int main()</code> <code class="sh_cpp">int
main(...)</code>-nak felelt meg, a paraméter nélküli függvényeket <code
class="sh_cpp">int main(void)</code>-ként kellett deklarálni. C++-ban ez már
nem érvényes, a <code class="sh_cpp">int main()</code> ekvivalens a <code
class="sh_cpp">int main(void)</code> deklarációval.</p>
<h2>Változó deklaráció bárhol</h2>
<p>Bárhol lehet változót deklarálni, nem csak a blokkok elején és a
for ciklusokban.</p>
<pre class="sh_cpp" data-source="new/decl.cc"></pre>
<h2>Függvények túlterhelése</h2>
<p>A függvényeket már nem csak a nevük, hanem a paraméterlistájuk is
azonosítja, amíg egyértelmű.</p>
<pre class="sh_cpp" data-source="new/overload.cc"></pre>
<pre class="console" data-source="new/overload.txt"></pre>
<p>Többek között emiatt van szükség az <code class="sh_cpp">extern "C"</code>
módosítóra.</p>
<h2>Függvény paraméter alapértelmezett értékek</h2>
<p>A függvény utolsó paramétereinek adhatunk alapértelmezett értéket, ezzel
azok a paraméterek elhagyhatóvá válnak.</p>
<pre class="sh_cpp" data-source="new/default.cc"></pre>
<pre class="console" data-source="new/default.txt"></pre>
<h2>Referenciák</h2>
<p>Mutatók mellett referenciákat is használhatunk. A háttérben ezek is
mutatók, de nem tudjuk a mutató értékét megváltoztatni, csak azt az értéket,
amire mutat. Ha a referenciát const kulcsszóval deklaráljuk, a fordító képes
automatikusan ideiglenes változót létrehozni, ha kell (lásd a példát).</p>
<pre class="sh_cpp" data-source="new/ref.cc"></pre>
<pre class="console" data-source="new/ref.txt"></pre>
<h2><code class="sh_cpp">inline</code> függvények</h2>
<p>A <code class="sh_cpp">#define</code> direktívával létrehozott
makró-függvényeknek kellemetlen mellékhatásai lehetnek:</p>
<pre class="sh_cpp">#define MUL(a, b) a*b
// ...
#define SIX 1+5
#define NINE 8+1
int val = MUL(SIX, NINE);
// val erteke 42 (nem 54)</pre>
<p>Zárójelezéssel javíthatunk rajta, a deklaráció nem lett szebb, és még így
is problémáink akadhatnak:</p>
<pre class="sh_cpp">#define MAX(a, b) ((a)>(b)?(a):(b))
// ...
int a = 6;
int b = 5;
int val = MAX(++a, b);
// a es val erteke mar 8</pre>
<p>Ezen kívül nincsenek típusdeklarációk, nem lehet használni a
túlterhelést, az alapértelmezett értékeket, és egyebeket, amikről eddig nem
volt szó. De szeretnénk, ha nem hajtana végre külön függvényhívást, ha a
fordító is úgy gondolja, hogy ez kézenfekvő.</p>
<pre class="sh_cpp">int max(int a, int b)
{
    return a > b ? a : b;
}
// ...
int a = 6;
int b = 5;
int val = max(++a, b);
// a es val erteke 7</pre>
</section>
</article>
<script type="application/javascript" src="js/sh_cpp.js"></script>
<script type="application/javascript" src="js/sh_main.js"></script>
<script type="application/javascript" src="http://ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
<script type="application/javascript" src="js/highlightDocument.js"></script>
</body>
</html>
